\documentclass{article}
\usepackage[latin1]{inputenc}

\begin{document}

\title{Tools and Algorithms for Deciding Timed Relations}

\author{Mihir Mehta\\
Department of Computer Science and Engineering,\\
Indian Institute of Technology, Delhi.\\
\texttt{cs1090197@cse.iitd.ac.in}
}

\date{December 2012}

\maketitle

\begin{abstract}
This is a report summarising the author's project on their B Tech
Project for the academic year 2012-2013.
\end{abstract}

\section{Objectives}

\begin{itemize}

\item To develop a software toolkit that would enable users to verify
  various timed relations specifications and implementations expressed
  as timed automata.

  \begin{itemize}

  \item To gain an understanding of the theory related to labeled
    transition systems, CCS processes and timed automata by surveying
    relevant literature.

  \item To study tools already built by researchers for similar purposes.

  \item To develop the software in a modular way with modules for
    language specification and modules for implementations of utility
    algorithms.

  \item To implement algorithms for determining timed relations.

  \end{itemize}

\end{itemize}

\section{CCS processes}

\begin{itemize}
\item A CCS process is an automaton with state and interfaces for
interaction. 
\item The interaction is in the form of \emph{actions} over
communication ports known as \emph{channels}. 
\item Given a port name $a$ we refer to $a$ as the label for input on the port
  and $\overline{a}$ as the label for the output on the port.
\item \emph{Inaction}: This is the simplest CCS process, denoted by
  $0$. No state transitions or communcation can occur, in other words,
  this represents a deadlock.
\item \emph{Prefixing}: This is the simplest constructor; if $P$ is a
  process and $a$ is a label (input or output) then $a.P$ is also a
  process which can perform the action $a$ in order to become the
  process P.

\item \emph{Naming}: We can give names to processes using syntax such as \\
$N \overset{def}{=} a_1.a_2.....0$ \\
This gives us the ability to define CCS processes recursively, such as
this one:\\
Parrot \overset{def}{\rightarrow} $a$.$\overline{a}$.Parrot

\item \emph{Choice}: If $P$ and $Q$ are processes, then $P+Q$ is a
  process as well which has the initial capabilities of both P and
  Q. The deadlock process $0$ is the identity element for this, that is,
  $P+0=P$ is an identity.

\item \emph{Parallel Composition}: If $P$ and $Q$ are
  processes, then $P|Q$ is a process as well in which P and Q may
  proceed independently or communicate via complementary ports.


\item \emph{Restriction}: If $P$ is a process and $L$ is a set of
  channel names, then $P/L$ is a process in which the component processes of $P$
  are the only processes which can communicate over channels from the
  set $L$.

\item \emph{Relabeling}: If $P$ is a process and $f$ is a function
  from labels to labels, then $P[f]$ is a process where each label
  from the domain of $f$ is replaced by its image under $f$. One
  application of relabelling is the idea of \emph{generic} processes:
  By relabelling the generic ports of such a process with specific
  port names, one can generate specific processes.

\end{itemize}

It is evident that each CCS process can be replaced by a labeled
transition system (LTS) with equivalent behaviour, therefore we will,
in the rest of this discussion, freely use the properties of LTS when
describing those of CCS.

\section{Equivalences on CCS}

\subsection{Trace equivalence}
  \begin{itemize}

  \item A \emph{trace} of an LTS is a sequence of actions
    that the LTS can perform.

  \item For an LTS $P$, the set $Traces(P)$ represents the set of all
    possible traces of $P$.
  \item Trace equivalence is said to exist between two LTS $P$ and $Q$
    when $Traces(P) = Traces(Q)$.
  \item However, this notion proves to have a significant limitation
    in the case of CCS processes: Two CCS processes can have trace equivalence
    between their corresponding LTS and yet behave differently in
    terms of when they deadlock while interacting with a third CCS process.
  \end{itemize}

\subsection{Strong bismilarity}
  \begin{itemize}
  \item \emph{Strong bisimulation}: A binary relation $R$ is a strong
    bisimulation if and only if, for all $(s_1, s_2) \epsilon R$ and $a \epsilon Act .$\\
    $\forall s_1' (s_1 \xrightarrow{a} s_1' \Rightarrow \exists s_2'
    . (s_2 \xrightarrow{a} s_2' \wedge (s_1', s_2') \epsilon R ) )
    \wedge $ \\
    $\forall s_2' (s_2 \xrightarrow{a} s_2' \Rightarrow \exists s_1'
    . (s_1 \xrightarrow{a} s_1' \wedge (s_1', s_2') \epsilon R ) )$
  \item It can be shown that the union of all strong bisimulations
    over the set of states is a strong bisimulation. This binary
    relation is called \texttt{strong bisimilarity}, denoted by $\sim$.
  \item This mitigates one of the failings of trace equivalence as an
    equivalence relation: strong bisimilarity between two CCS
    processes ensures identical deadlock behaviour while interacting
    with a third CCS process.
  \item However, another limitation soon becomes apparent: if two CCS
    processes are to be strongly bisimilar, they must coincide even on
    the number and position of $\tau$ transitions in their
    traces. This is contrary to the semantics of CCS processes, as
    a $\tau$ transition is supposed to be private to a process and
    invisible to all other processes in its environment.

  \end{itemize}

\subsection{Weak bismilarity}

  \begin{itemize}
  \item Weak bisimulation: A binary relation $R$ is a \texttt{weak
    bisimulation} if and only if, for all $(s_1, s_2) \epsilon R$ and $a \epsilon Act .$\\
    $\forall s_1' (s_1 \xrightarrow{a} s_1' \Rightarrow \exists s_2'
    . (s_2 \overset{a}{\Rightarrow} s_2' \wedge (s_1', s_2') \epsilon R ) )
    \wedge $ \\
    $\forall s_2' (s_2 \xrightarrow{a} s_2' \Rightarrow \exists s_1'
    . (s_1 \overset{a}{\Rightarrow} s_1' \wedge (s_1', s_2') \epsilon R ) )$
  \item It can be shown that the union of all weak bisimulations
    over the set of states is a weak bismulation. This binary
    relation is called \texttt{weak bisimilarity}, denoted by $\approx$.
  \item Better suited to CCS processes,
    as it ignores $\tau$ transitions, thus disregarding hidden
    behaviour within a process.
  \end{itemize}

\subsection{Kanellakis and Smolka's algorithm}

  \begin{itemize}
  \item This is a naive algorithm for determining the bisimilarity
    relation for the set of processes in a labelled transition system.
  \item This relies on the notion of a splitter.
  \item Let $\pi = \{ B_0, ..., B_k \}, k \ge 0$ be a partition of the
    set of states $Pr$ in a labeled transition system.
  \item A splitter for a block $B_i$ $\epsilon$ $\pi$ is a block $B_j$
    $\epsilon$ $\pi$ such that for some action $a$ $\epsilon$ $Act$, some
    states in $B_i$ have $a$-labelled transitions whose targets lie in
    $B_j$ while other states in $B_i$ do not.
  \item This suggests a refinement of $\pi$: replace block $B_i$ with
    \\
    $B_i^1 = B_i \cap T_a^{-1}[B_j] $ \\
    $B_i^2 = B_i - B_i^1 $ 
  \item Refinements of this kind constitute the steps of this
    algorithm.
  \item The time complexity of this algorithm is $O(mn)$, since there
    can be at most n iterations, and all m edges are scanned in each iteration.
  \end{itemize}

\subsection{Fernandez' algorithm}

  \begin{itemize}
  \item This is a more efficient algorithm for determining bisimilarity (O(m log n)).
  \item This relies on the technique of three-way splitting introduced
    by Paige and Tarjan.
  \item Splitters can now be 'simple' or 'compound'.
  \item Stability: A partition $\pi$ is said to be stable with respect to a
    compound block S if S is not a splitter for any block in $\pi$ for
    any action.
  \item For a compound block S, having a constituent simple block B
    satisfying $n(B) \le 0.5*n(S)$, and with respect to which $\pi$ is
    stable, we can split a block $B_i$ on an action $a$ as follows:\\
    $B_i^1 = (B_i \cap T_a^{-1}[B]) - T_a^{-1}[S-B]$ \\
    $B_i^2 = (B_i \cap T_a^{-1}[S-B]) - T_a^{-1}[B]$ \\
    $B_i^3 = B_i \cap T_a^{-1}[B] \cap T_a^{-1}[S-B]$ \\
  \end{itemize}

\section{Timed automata}

  \begin{itemize}
  \item Formally, a timed automaton over a finite set of clocks $C$
    and a finite set of actions $Act$ is a 4-tuple $(L, l_{0}, E, I)$.
  \item $L$ is a finite set of locations.
  \item $l_{0}$ is the initial location.
  \item $E \subseteq L \times B(C) \times Act \times 2^{C} \times L$
    is a finite set of edges.
  \item $I: L \rightarrow B(C)$ assigns invariants to each edge
    location.
  \item $B(C)$ is the set of clock constraints over C. An element of $B(C)$
    can be an equality, a slack inequality, a strict inequality, or
    an AND combination of such constraints.
  \end{itemize}

\section{Equivalences on Timed Automata}

\subsection{Timed bismilarity}



\subsection{Time abstracted bisimilarity}

\subsection{Regions and region graphs}

\subsection{Zones and zone graphs}

\end{document}
