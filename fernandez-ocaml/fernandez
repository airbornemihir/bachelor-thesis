#use "topfind";;
#require "inspect";;
open Inspect;;
type action = int;;
type ltsindex = int;;
type node = {mutable in_adjacency: (action * (ltsindex list)) list};;
type lts = node array;;
type block = ltsindex list;;
type partition = block list;;
type splitter = Simple of block | Compound of (block * splitter * splitter);;

(*
  t is the tree
  x is the formerly simple block that was split into the new simple blocks x1 and x2
 *)
let rec twowayupdatetree t x x1 x2 =
  match t with
    Simple t0 -> if (t0 = x) then (Compound (x, Simple x1, Simple x2), true) else (t, false)
  | Compound (t0, t1, t2) -> (
      match (twowayupdatetree t1 x x1 x2) with
	(_, false) -> (
	  match (twowayupdatetree t2 x x1 x2) with
	    (_, false) -> (t, false)
	  | (tt2, true) -> (Compound (t0, t1, tt2), true)
	 )
      | (tt1, true) -> (Compound (t0, tt1, t2), true)
     )
;;

let rec twowayupdatequeue w x x1 x2 =
  match w with
    [] -> [Compound (x, Simple x1, Simple x2)]
  | t::ts -> (match (twowayupdatetree t x x1 x2) with
      (_, false) -> t::(twowayupdatequeue ts x x1 x2)
    | (tt, true) -> tt::ts
     )
;;

 (*
   l is the lts
   x is the block being split
   b is the simple splitter
   a is the action
   return type: pair of blocks, one of which may be empty
  *)
 let simplesplitblockonaction l x b a =
   List.partition (function xelem -> List.exists (function belem -> List.exists (function (aa, nl) -> a=aa && List.exists (function nlelem -> nlelem = xelem) nl) l.(belem).in_adjacency) b) x
 ;;

(*
  l is the lts
  x is the block being split
  b is the compound splitter consisting of b1 and b2
  a is the action
 *)
let compoundsplitblockonaction l x b b1 b2 a = let
  f = function xelem -> List.exists (function belem -> List.exists (function (aa, nl) -> a=aa && List.exists (function nlelem -> nlelem = xelem) nl) l.(belem).in_adjacency)
  in match
  (List.partition (function xelem -> f xelem b1) x)
  with
  (y1, y2) -> (List.partition (function xelem -> f xelem b2) y1, List.partition (function xelem -> f xelem b2) y2)
;;

(*
  l is the lts
  w is the queue
  xl is the list of blocks being split
  b is the simple splitter
  a is the action
 *)
let rec simplesplitblocksonaction l (w, xl) b a =
  match xl with
    [] -> (w, [])
  | x::xs -> (let (ww, xxs) = (simplesplitblocksonaction l (w, xs) b a) in (match (simplesplitblockonaction l x b a) with
      ([], x2) -> (ww, x2::xxs)
    | (x1, []) -> (ww, x1::xxs)
    | (x1, x2) -> (let www = (twowayupdatequeue ww x x1 x2) in (www, x1::x2::xxs))
									   ))
;;

let rec compoundsplitblocksonaction l (w, xl) b b1 b2 a =
  match xl with
    [] -> (w, [])
  | x::xs -> (let (ww, xxs) = (compoundsplitblocksonaction l (w, xs) b b1 b2 a) in (match (compoundsplitblockonaction l x b b1 b2 a) with
      (([], []), ([], x4)) -> (ww, x4::xxs)
    | (([], x1), ([], [])) -> (ww, x1::xxs)
    | (([], []), (x2, [])) -> (ww, x2::xxs)
    | ((x3, []), ([], [])) -> (ww, x3::xxs)
    | ((x3, x1), ([], [])) -> (let www = (twowayupdatequeue ww x x3 x1) in (www, x3::x1::xxs))
    | ((x3, []), (x2, [])) -> (let www = (twowayupdatequeue ww x x3 x2) in (www, x3::x2::xxs))
    | (([], x1), (x2, [])) -> (let www = (twowayupdatequeue ww x x1 x2) in (www, x1::x2::xxs))
    | ((x3, x1), (x2, [])) -> (let www = (twowayupdatequeue (twowayupdatequeue ww x x1 (x2@x3)) (x2@x3) x2 x3) in (www, x1::x2::x3::xxs))
     ))
;;

(*
  alias for sanity
 *)
let splitpartitiononaction l (w, pi) sp a = match sp with
  Simple b -> simplesplitblocksonaction l (w, pi) b a
| Compound (b, Simple b1, Simple b2) -> compoundsplitblocksonaction l (w, pi) b b1 b2 a
| Compound (b, Compound (b1, _, _), Simple b2) -> compoundsplitblocksonaction l (w, pi) b b1 b2 a
| Compound (b, Simple b1, Compound (b2, _, _)) -> compoundsplitblocksonaction l (w, pi) b b1 b2 a
| Compound (b, Compound (b1, _, _), Compound (b2, _, _)) -> compoundsplitblocksonaction l (w, pi) b b1 b2 a
;;

(*
  l is the lts
  pi is the partition being split
  w is the queue
  b is the simple splitter
  a is the LAST action
 *)
let rec splitpartitiononactions l (w, pi) b a =
  match a with
    0 -> splitpartitiononaction l (w, pi) b 0
  | a -> splitpartitiononaction l (splitpartitiononactions l (w, pi) b (a-1)) b a
;;

let dequeue l (w, pi) a = match w with
  [] -> ([], pi)
| (Simple b)::wtail -> splitpartitiononactions l (wtail, pi) (Simple b) a
| (Compound (b, b1, b2))::wtail -> splitpartitiononactions l (wtail@[b1; b2], pi) (Compound (b, b1, b2)) a
;;

let rec emptyqueue l (w, pi) a = match w with
  [] -> ([], pi)
| whead::wtail -> emptyqueue l (dequeue l (w, pi) a) a
;;

let rec getblock n = match n with
  0 -> []
| n -> (n-1)::(getblock (n-1))
;;
      
let fernandez l a = let llist = getblock (Array.length l) in emptyqueue l ([Simple llist], [llist]) a
;;

let lts1 = [|{in_adjacency = [(2, [6])]}; 
	     {in_adjacency = [(0, [1])]}; 
	     {in_adjacency = [(0, [0]); (1, [7])]};
	     {in_adjacency = [(1, [2])]};
	     {in_adjacency = [(1, [2])]};
	     {in_adjacency = [(0, [4; 5]); (2, [6])]};
	     {in_adjacency = [(1, [3]); (2, [2])]};
	     {in_adjacency = [(0, [1])]}|]
;;

let x1 = [0; 1; 2; 3; 4; 5; 6; 7];;
let b1 = [0; 1; 2; 3; 4; 5; 6; 7];;
let pi1 = [[0; 1; 2; 3; 4; 5; 6; 7]];;
let a1 = 0;;
let w1 = [];;
let (w1, pi1) = simplesplitblocksonaction lts1 (w1, pi1) b1 a1;;
let a1 = 1;;
let (w1, pi1) = simplesplitblocksonaction lts1 (w1, pi1) b1 a1;;
let a1 = 2;;
let (w1, pi1) = simplesplitblocksonaction lts1 (w1, pi1) b1 a1;;
let b2 = [0; 1; 2; 3; 4; 5; 6; 7];;
let b3 = [0; 1; 4; 5];;
let b4 = [2; 3; 6; 7];;
let pi2 = [[0; 1; 4; 5; 2; 3; 6; 7]];;
let w2 = [Simple [0; 1; 2; 3; 4; 5; 6; 7]];;
let a2 = 2;;
let lts1 = [|{in_adjacency = [(2, [6])]}; 
	     {in_adjacency = [(0, [1])]}; 
	     {in_adjacency = [(0, [0]); (1, [7])]};
	     {in_adjacency = [(1, [2])]};
	     {in_adjacency = [(1, [2])]};
	     {in_adjacency = [(0, [4; 5]); (2, [6])]};
	     {in_adjacency = [(1, [3]); (2, [2])]};
	     {in_adjacency = [(0, [1])]}|]
;;
let (w2, pi2) = fernandez lts1 2;;
let lts2 = [|{in_adjacency = [(0, [5])]}; 
	     {in_adjacency = [(0, [0; 1])]}; 
	     {in_adjacency = [(1, [4])]};
	     {in_adjacency = [(0, [6]); (1, [2])]};
	     {in_adjacency = [(1, [3])]};
	     {in_adjacency = []};
	     {in_adjacency = [(1, [5])]}
	   |]
;;
let (w3, pi3) = fernandez lts2 1;;
