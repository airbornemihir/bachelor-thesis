<<grammar_types.mli>>=
module Valuation: Map.S with type key=string

<<grammar_types.ml>>=
module Valuation = Map.Make (String)

<<grammar_types.mli>>=
type unit_clock_constraint = True
		       | False
		       | Lt of string*int
		       | Le of string*int
		       | Eq of string*int
		       | Ge of string*int
		       | Gt of string*int

<<grammar_types.ml>>=
type unit_clock_constraint = True
		       | False
		       | Lt of string*int
		       | Le of string*int
		       | Eq of string*int
		       | Ge of string*int
		       | Gt of string*int

<<grammar_types.mli>>=
type clock_constraint = unit_clock_constraint list

<<grammar_types.ml>>=
type clock_constraint = unit_clock_constraint list

<<grammar_types.mli>>=
type transition = {
  action: int;
  condition: clock_constraint;
  clock_resets: string array;
  next_location: int
}

<<grammar_types.ml>>=
type transition = {
  action: int;
  condition: clock_constraint;
  clock_resets: string array;
  next_location: int
}

<<grammar_types.mli>>=
type location = {
  location_index: int;
  invariant: clock_constraint;
  departures: transition array
}

<<grammar_types.ml>>=
type location = {
  location_index: int;
  invariant: clock_constraint;
  departures: transition array
}

<<grammar_types.mli>>=
type timed_automaton = {
  numlocations: int;
  numtrans: int;
  numclocks: int;
  numactions: int;
  numinit: int;
  clock_names: string array;
  locations: location array
}

<<grammar_types.ml>>=
type timed_automaton = {
  numlocations: int;
  numtrans: int;
  numclocks: int;
  numactions: int;
  numinit: int;
  clock_names: string array;
  locations: location array
}

<<grammar_types.mli>>=
type state = {
  location: int;
  valuation: float Valuation.t
}

<<grammar_types.ml>>=
type state = {
  location: int;
  valuation: float Valuation.t
}
