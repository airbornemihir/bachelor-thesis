\subsection{Alt_Fernandez_modules.ml}
This file provides an alternate implementation of Fernandez' algorithm
    using Ocamlgraph.

<<Alt_Fernandez_modules.ml>>=
open Graph

module type LTS_STATE_TYPE =
sig
  include Sig.COMPARABLE
  val state_name: t -> string
end

module type LTS_ACTION_TYPE = 
sig
  include Sig.ORDERED_TYPE_DFT
  type action = t
  module ActionMap : Map.S with type key=action
  val action_names: string ActionMap.t
end
  
module type LTS_TYPE =
sig
  include Sig.P
  type action = E.label
  module ActionMap : Map.S with type key=action
  val action_names: string ActionMap.t
  val graph_attributes : t -> Graphviz.DotAttributes.graph list
  val default_vertex_attributes : t -> Graphviz.DotAttributes.vertex list
  val vertex_name : V.t -> string
  val vertex_attributes : V.t -> Graphviz.DotAttributes.vertex list
  val get_subgraph : V.t -> Graphviz.DotAttributes.subgraph option
  val default_edge_attributes : t -> Graphviz.DotAttributes.edge list
  val edge_attributes : E.t -> Graphviz.DotAttributes.edge list
end

module LTS_Functor = 
  functor (S : LTS_STATE_TYPE) -> 
    functor (A : LTS_ACTION_TYPE) ->
      (struct

        module Base = Persistent.Digraph.ConcreteBidirectionalLabeled
          (S) (A)
        include Base
          
        let vertex_name = S.state_name

        type action = A.t
        module ActionMap = A.ActionMap
        let action_names = A.action_names
          
        let mod_add_edge add_edge g v1 v2 =
          if
            A.ActionMap.mem A.default (A.action_names)
          then
            add_edge g v1 v2
          else
            raise (Invalid_argument "Invalid action.")
          
        let mod_add_edge_e add_edge_e g e =
          if
            A.ActionMap.mem (E.label e) (A.action_names)
          then
            add_edge_e g e
          else
            raise (Invalid_argument "Invalid action.")
              
        let add_edge_e = mod_add_edge_e add_edge_e

        let add_edge = mod_add_edge add_edge

        let graph_attributes g  = []

        let default_vertex_attributes g = []

        let vertex_attributes v = []

        let get_subgraph v = None

        let default_edge_attributes g = []

        let edge_attributes (_, a, _) = [`Label (ActionMap.find a action_names)]
       end
         : LTS_TYPE  with type V.t = S.t and type V.label = S.t
                  and type E.t = S.t * A.t * S.t and type E.label = A.t
      )

module LTS_Dot_Functor =
  functor (LTS: LTS_TYPE) ->
struct
  include Graphviz.Dot (LTS)
end

module Fernandez_Functor =
  functor (LTS: LTS_TYPE) ->
struct
  module StateSet = Set.Make(LTS.V)
  module InfoMap = Map.Make(
    struct
      type t = LTS.action * LTS.V.t
      let compare = Pervasives.compare
    end
  )
  type block = {
    node_refs: StateSet.t;
    info: int InfoMap.t
  }
  module BlockSet = Set.Make(
    struct
      type t = block
      let compare = Pervasives.compare
    end
  )
  type partition = BlockSet.t
  type splitter = Simple of block | Compound of block * splitter * splitter

  let rec two_way_update_tree t x x1 x2 =
    match t with
    | Simple t0 ->
        if
          StateSet.equal t0.node_refs x.node_refs
        then
          (Compound (x, Simple x1, Simple x2), true)
        else
          (t, false)
    | Compound (t0, t1, t2) ->
      match
        (two_way_update_tree t1 x x1 x2)
      with
      | (_, false) -> (
          match
            (two_way_update_tree t2 x x1 x2)
          with
          | (_, false) -> (t, false)
          | (tt2, true) -> (Compound (t0, t1, tt2), true)
         )
      | (tt1, true) -> (Compound (t0, tt1, t2), true)

  let rec two_way_update_queue w x x1 x2 =
    match w with
      [] -> [Compound (x, Simple x1, Simple x2)]
    | t::ts -> (match (two_way_update_tree t x x1 x2) with
      (_, false) -> t::(two_way_update_queue ts x x1 x2)
      | (tt, true) -> tt::ts
    )

  let get_info l node_refs =
    LTS.fold_vertex
      (function v ->
        function m ->
          LTS.ActionMap.fold
            (function action ->
              function action_name ->
                function m ->
                  InfoMap.add
                    (action, v)
                    (LTS.fold_succ_e
                       (function e ->
                         function count ->
                           if
                             (*The following expression is meant to
                               compare the two actions using their
                               own semantics, instead of
                               Pervasives.(=), because the latter is
                               inaccurate and because lame data
                               hiding only allows this way of using
                               the actions' own semantics for comparison.*)
                             (LTS.ActionMap.cardinal
                                (LTS.ActionMap.add
                                   action
                                   ()
                                   (LTS.ActionMap.add
                                      (LTS.E.label e)
                                      ()
                                      LTS.ActionMap.empty
                                   )
                                )
                              = 1
                                 &&
                                   (StateSet.mem
                                      (LTS.E.dst e)
                                      node_refs
                                   )
                             )
                           then
                             count + 1
                           else
                             count
                       )
                       l
                       v
                       0
                    )
                    m
            )
            LTS.action_names
            m
      )
      l
      InfoMap.empty

  let get_block_from_node_refs l node_refs =
    {node_refs = node_refs;
     info =
        (get_info l node_refs)
    }

  let simple_split_block_on_action l x b action =
    match
      StateSet.partition
        (function xelem ->
          LTS.fold_succ_e
            (function e ->
              Pervasives.(||)
                (
                  (StateSet.mem
                     (LTS.E.dst e)
                     b.node_refs
                  ) &&
                    LTS.ActionMap.cardinal
                    (LTS.ActionMap.add
                       action
                       ()
                       (LTS.ActionMap.add
                          (LTS.E.label e)
                          ()
                          LTS.ActionMap.empty
                       )
                    )
                  = 1
                )
            )
            l
            xelem
            false
        )
        x.node_refs
    with
      (x1indices, x2indices) ->
        (get_block_from_node_refs l x1indices, get_block_from_node_refs l x2indices)
end

module Test =
struct
  module V =
  struct
    type t = int
    let compare = Pervasives.compare
    let hash = Hashtbl.hash
    let equal = Pervasives.(=)
    let state_name = string_of_int
  end

  module E1 =
  struct
    type t = int
    let compare = Pervasives.compare
    let default = 0
    type action = t
    module ActionMap = Map.Make(
      struct
        type t = action
        let compare = Pervasives.compare
      end
    )
    let action_names =
      ActionMap.add 2 "2" (ActionMap.add 1 "1" (ActionMap.add 0 "0" ActionMap.empty))
  end

  module IntIntLTS1 = LTS_Functor (V) (E1)

  let test93 =
    try
      match
        IntIntLTS1.add_edge IntIntLTS1.empty 0 1
      with
      | _ -> "test93 passed"
    with
    | Invalid_argument _ -> "test93 failed"

  let test94 =
    try
      match
        IntIntLTS1.add_edge_e IntIntLTS1.empty (0, 0, 1)
      with
      | _ -> "test94 passed"
    with
    | Invalid_argument _ -> "test94 failed"

  let test95 =
    try
      match
        IntIntLTS1.add_edge_e IntIntLTS1.empty (0, -1, 1)
      with
      | _ -> "test95 failed"
    with
    | Invalid_argument _ -> "test95 passed"

  module E2 =
  struct
    include E1
    let action_names = ActionMap.add 3 "3" (ActionMap.add 2 "2" (ActionMap.add 1 "1" ActionMap.empty))
  end

  module IntIntLTS2 = LTS_Functor (V) (E2)

  module IntIntLTS1Dot = LTS_Dot_Functor (IntIntLTS1)

  module IntIntLTS2Dot = LTS_Dot_Functor (IntIntLTS2)

  let test96 =
    try
      match
        IntIntLTS2.add_edge IntIntLTS2.empty 0 1
      with
      | g -> "test96 failed"
    with
    | Invalid_argument _ -> "test96 passed"

  let test97 =
    try
      match
        IntIntLTS2.add_edge_e IntIntLTS2.empty (0, 3, 1)
      with
      | g -> "test97 passed"
    with
    | Invalid_argument _ -> "test97 failed"

  let l01 =
    List.fold_left
      (fun g e -> IntIntLTS1.add_edge_e g e)
      (IntIntLTS1.add_vertex IntIntLTS1.empty 7)
      [(0, 0, 1); (1, 0, 1); (2, 1, 3); (3, 1, 4); (4, 1, 2); (5, 0, 0);
       (6, 0, 3); (5, 1, 6)]

  module F1 = Fernandez_Functor (IntIntLTS1)

  let splitter01 =
    F1.Compound
      ({F1.node_refs =
          F1.StateSet.add
            4
            (F1.StateSet.add
               3
               (F1.StateSet.add
                  2
                  (F1.StateSet.add
                     1
                     (F1.StateSet.add 0 F1.StateSet.empty)
                  )
               )
            );
        F1.info = F1.InfoMap.empty
       },
       F1.Simple
         {F1.node_refs =
             F1.StateSet.add 1 (F1.StateSet.add 0 F1.StateSet.empty);
          F1.info = F1.InfoMap.empty
         },
       F1.Compound
         ({F1.node_refs =
             F1.StateSet.add
               4
               (F1.StateSet.add
                  3
                  (F1.StateSet.add 2 F1.StateSet.empty)
               );
           F1.info = F1.InfoMap.empty
          },
          F1.Simple
            {F1.node_refs = F1.StateSet.add 2 F1.StateSet.empty;
             F1.info = F1.InfoMap.empty
            },
          F1.Simple
            {F1.node_refs =
                F1.StateSet.add
                  3
                  (F1.StateSet.add 4 F1.StateSet.empty)
            ;
             F1.info = F1.InfoMap.empty
            }
         )
      )

  let splitter02 =
    F1.Compound
      ({F1.node_refs =
          F1.StateSet.add
            4
            (F1.StateSet.add
               3
               (F1.StateSet.add
                  2
                  (F1.StateSet.add
                     1
                     (F1.StateSet.add 0 F1.StateSet.empty)
                  )
               )
            );
        F1.info = F1.InfoMap.empty
       },
       F1.Simple
         {F1.node_refs =
             F1.StateSet.add 1 (F1.StateSet.add 0 F1.StateSet.empty);
          F1.info = F1.InfoMap.empty
         },
       F1.Compound
         ({F1.node_refs =
             F1.StateSet.add
               4
               (F1.StateSet.add
                  3
                  (F1.StateSet.add 2 F1.StateSet.empty)
               );
           F1.info = F1.InfoMap.empty
          },
          F1.Simple
            {F1.node_refs = F1.StateSet.add 2 F1.StateSet.empty;
             F1.info = F1.InfoMap.empty
            },
          F1.Compound
            ({F1.node_refs =
                F1.StateSet.add
                  4
                  (F1.StateSet.add 3 F1.StateSet.empty)
            ;
             F1.info = F1.InfoMap.empty
            },
             F1.Simple
               {F1.node_refs = F1.StateSet.add 4 F1.StateSet.empty;
                F1.info = F1.InfoMap.empty
               },
             F1.Simple
               {F1.node_refs = F1.StateSet.add 3 F1.StateSet.empty;
                F1.info = F1.InfoMap.empty
               }
            )
         )
      )

  let block01 =
    {F1.node_refs =
        F1.StateSet.add
          7
          (F1.StateSet.add
             6
             (F1.StateSet.add 5 F1.StateSet.empty)
          );
     F1.info = F1.InfoMap.empty
    }

  let block02 =
    {F1.node_refs =
        F1.StateSet.add
          7
          (F1.StateSet.add 5 F1.StateSet.empty)
    ;
     F1.info = F1.InfoMap.empty
    }

  let block03 =
    {F1.node_refs =
        F1.StateSet.add 7 F1.StateSet.empty
    ;
     F1.info = F1.InfoMap.empty
    }

  let block04 =
    {F1.node_refs =
        F1.StateSet.add
          4
          (F1.StateSet.add 3 F1.StateSet.empty)
    ;
     F1.info = F1.InfoMap.empty
    }

  let block05 =
    {F1.node_refs =
        F1.StateSet.add 4 F1.StateSet.empty
    ;
     F1.info = F1.InfoMap.empty
    }

  let block06 =
    {F1.node_refs =
        F1.StateSet.add 3 F1.StateSet.empty
    ;
     F1.info = F1.InfoMap.empty
    }

  let test98 =
    if
      F1.two_way_update_tree splitter01 block01 block02 block03 =
      (splitter01, false)
    then
      "test98 passed"
    else
      "test98 failed"

  let test99 =
    if
      F1.two_way_update_tree splitter01 block04 block05 block06 =
      (splitter02, true)
    then
      "test99 passed"
    else
      "test99 failed"

  let l02 =
    List.fold_left
      (fun g e -> IntIntLTS1.add_edge_e g e)
      IntIntLTS1.empty
      [(0, 1, 1); (0, 1, 2); (1, 0, 2); (2, 0, 1)]

  let block08 = F1.get_block_from_node_refs l02 (F1.StateSet.add 2 (F1.StateSet.add 1 F1.StateSet.empty))

  let test100 =
    if
      F1.InfoMap.find (1, 0) block08.F1.info = 2
    then
      "test100 passed"
    else
      "test100 failed, cardinal = " ^
        (string_of_int
           (F1.InfoMap.cardinal block08.F1.info)
        )

  let test101 =
    if
      F1.InfoMap.find (0, 1) block08.F1.info = 1
    then
      "test101 passed"
    else
      "test101 failed, cardinal = " ^
        (string_of_int
           (F1.InfoMap.cardinal block08.F1.info)
        )

  let test102 =
    if
      F1.InfoMap.find (1, 1) block08.F1.info = 0
    then
      "test102 passed"
    else
      "test102 failed"

  let block09 =
    F1.get_block_from_node_refs
      l02 (F1.StateSet.add 2 (F1.StateSet.add 1 (F1.StateSet.add 0 F1.StateSet.empty)))

  let test103 =
    if
      match
        F1.simple_split_block_on_action l02 block09 block09 0
      with
      | (x1, x2) ->
        (F1.StateSet.equal
           x1.F1.node_refs
           (F1.StateSet.add 2 (F1.StateSet.add 1 F1.StateSet.empty))
        ) && (F1.StateSet.equal
                x2.F1.node_refs
                (F1.StateSet.add 0 F1.StateSet.empty)
         )
    then
      "test103 passed"
    else
      "test103 failed"

  let test104 =
    if
      match
        F1.simple_split_block_on_action l02 block09 block09 1
      with
      | (x1, x2) ->
        (F1.StateSet.equal
           x1.F1.node_refs
           (F1.StateSet.add 2 (F1.StateSet.add 1 F1.StateSet.empty))
        ) && (F1.StateSet.equal
                x2.F1.node_refs
                (F1.StateSet.add 0 F1.StateSet.empty)
         )
    then
      "test104 passed"
    else
      "test104 failed"

end
