\chapter{Algorithms}

\section{Fernandez' algorithm}

This algorithm is summarised here from
\cite{fernandez1990implementation}. This algorithm follows a strategy
of repeatedly splitting a partition of the states of the LTS, into a
finer partition, until a fixpoint is reached and no further refinement
is possible. The details of two-way splitting and three-way splitting
are omitted for brevity.

\begin{algorithm2e}[H]
  Initialise $\pi = \{Pr\}$\;
  Initialise W = $\{Pr\}$
  \While{W is not empty}{
    Choose a splitter B from W, removing it\;
    \eIf{B is a simple splitter}{
      Perform a two-way split on each action with respect to B and
      update W\;
    }{
      Perform a three-way split on each action with respect to B and
      update W\;
    }
  }
\end{algorithm2e}

\section{Creation of the zone valuation graph}

\subsection{Overview}

This algorithm is adapted from the algorithms in
\cite{DBLP:conf/cav/GuhaNA12} and \cite{guha2013notes}. We changed it
to make the correctness more evident. 
This algorithm consists of a \emph{forward
  propagation} which ensures that all \emph{reachable} zones are created, and a
\emph{backward propagation} which ensures that each zone is \emph{stable} with
respect to its successors. \\

For the forward propagation, we use a queue,
akin to the queue of the classic \emph{breadth-first search} algorithm
for graphs, to traverse the timed automaton, starting from the initial
location, to ensure that all reachable zones are created. In each
queue element (with the exception of the first element containing the
inital location, which has no predecessor), we store a location
$l_{succ}$, its predecessor in the current path $l_{pred}$, and the
transition $t$ from $l_{pred}$ to $l_{succ}$. It should be noted
that this may result in some locations being visited multiple times,
and in unreachable locations never being visited. Each time a location
is visited, we create therein, new zones which are reachable from the
zones of the predecessor. \\
Thus, for each predecessor zone $(l_{pred}, \zeta _{pred_{i}})$, the
derived successor zone is $(l_{succ}, \zeta _{succ_{i}})$, where

\begin{displaymath} 
  \zeta _{succ_{i}} = ((\zeta _{pred_{i}} \uparrow \cap \texttt{t.guard})[\texttt{t.resets} := 0]) \uparrow
\end{displaymath} 

Thus, if we let  $(l_{pred}, \zeta _{pred_{i}})$ range over the
existing zones of $l_{pred}$, and if we let  $(l_{succ}, \zeta
_{succ_{j}})$ range over the existing zones of $l_{succ}$, then the
new zones in $l_{succ}$ will cover

\begin{displaymath} 
  \zeta _{succ_{new}} = (\bigcup _{i} \zeta_{succ_{i}}) - (\bigcup _{j} \zeta_{succ_{j}})
\end{displaymath} 

% define convex polyhedra, future operators, etc.
Since $\zeta _{succ_{new}}$ is not necessarily convex, we may need to
split it into multiple convex polyhedra before creating the
corresponding zones in the $l_{succ}$. Then, we split the zones of
$l_{succ}$ to ensure stability with respect to
its invariant and outgoing edge constraints. If any new
zones are thus created, we enqueue each of the location's successors,
in order to ensure that all reachable zones are created. The forward
propagation ends when the queue is empty. \\

In the backward propagation, we
iterate through the transitions of the timed automaton, multiple times
if necessary, splitting the zones of the source of each transition
with respect to the zones of the transition's target, until we achieve
stability of each zone of each location. We recall that for stability,
whenever we have an edge in the zone valuation graph from a zone
$(l_{pred}, \zeta _{pred})$ to $(l_{succ}, \zeta _{succ})$
corresponding to a transition $t$ in the timed automaton, we require 
\begin{displaymath} 
  \zeta _{pred} \subseteq \texttt{t.guard}
  \wedge
  \zeta _{pred} [\texttt{t.resets} := 0] \subseteq \zeta _{succ}
\end{displaymath} 
Thus, when this does not hold, we split $(l_{pred}, \zeta _{pred})$
into
\begin{displaymath} 
  (l_{pred}, \zeta _{pred} \cap (\texttt{t.guard} \cap [\texttt{t.resets} := 0] \zeta _{succ}))
\end{displaymath} 
(which is convex and has an edge to $(l_{succ}, \zeta _{succ})$)
and
\begin{displaymath} 
  (l_{pred}, \zeta _{pred} - (\texttt{t.guard} \cap [\texttt{t.resets} := 0] \zeta _{succ}))
\end{displaymath} 
(which does not have an edge to $(l_{succ}, \zeta _{succ})$ and may
need to be split into convex zones.) \\
This generates the zone valuation graph.

Pseudocode for this follows.

\begin{algorithm2e}[H]
  Initialise the queue $Q$ with a single element $(null, null, l_0)$\;
  Initialise the graph $zone\_graph$ with a single node $(l_0, v_0 \uparrow)$
  with an $\epsilon$ self-loop\;
  \While{$Q$ is not empty}{
    Dequeue $(l_{parent}, t, l_{child})$ from $Q$\;
    \If{$l_{parent} \neq null$}{
      \ForEach{zone $Z_{parent}$ of $l_{parent}$}{
        Add new zones to the zones of $l_{child}$ so that all zones
        reachable from $Z_{parent}$ are represented\;
        Abstract if necessary\;
        Update edges from $Z_{parent}$ to the new zones of $l_{child}$
        \If{new zones are created in $l_{child}$ or $l_{parent}$ is null}{
          \ForEach{outgoing transition $t'$ of $l_{child}$}{
            Enqueue $(l_{child}, t', \texttt{t'.target})$ in $Q$\;
          }
        }
      }
    }
    Set $new\_zone$\;
    \While{$new\_zone$}{
      Reset $new\_zone$\;
      \ForEach{transition $t$ in the timed automaton}{
        Split the zones of \texttt{t.source} to be stable with respect to the
        zones of \texttt{t.target}\;
        Update edges accordingly\;
        \If{new zones are created in \texttt{t.source}}{
          Set $new\_zone$\;
        }
      }
    }
  }
  Generate $zone\_valuation\_graph$ by applying Fernandez' algorithm to $zone\_graph$\;
  Return $zone\_graph$\;
\end{algorithm2e}

\subsection{Proof of correctness}

\begin{itemize}

\item \texttt{Termination}: The algorithm, in the worst case,
  will create as many zones as there are regions in the region graph,
  as the region graph abstraction ensures that the number of zones
  cannot exceed the number of regions. Since the number of regions is
  known to be bounded, termination of the algorithm is
  guaranteed.

\item \texttt{Reachability}: Since the initial zone is the future of
  the zero valuation in the initial zone, it is reachable by
  definition. A new zone is only created when it is reachable from some
  zone which has already been created, thus each zone which is created
  is reachable by induction.

\item \texttt{Stability}: Since the termination of the backward
  propagation step only occurs after an iteration in which all the
  edges of the timed automaton are traversed without causing any
  splitting of states, it follows that the zone graph is stable with
  respect to itself after this last iteration.

\end{itemize}

\section{Checking timed and untimed relations on timed automata}

\subsection{Overview}

Many important relations on timed automata can be verified by arguing
about the existence of winning strategies on two-player games. The
algorithm described here uses this fact to verify these relations
by simulating the two-player games, using a memoisation approach.

The relations which can be verified in this fashion are those in which
functions $f_P, f_Q$ exist such that
the question `Are symbolic states $s_P$ and $s_Q$ in timed automata $P$ and $Q$
related under $R$? ` can have three possible answers:
\begin{enumerate}
\item yes
\item no
\item if and only if 
  \begin{align*} 
    &\forall (s_P', L_Q') \epsilon f_P(s_P, s_Q): \exists s_Q' \epsilon
    L_Q': s_P' R s_Q' \quad \wedge \\
    &\forall (L_P', s_Q') \epsilon f_Q(s_P, s_Q): \exists s_P' \epsilon
    L_P': s_P' R s_Q'
  \end{align*} 
\end{enumerate}

This property is satisfied by timed bisimulation, STaB, TadB, TaoB,
and the corresponding simulation equivalences, among others.

So, for STaB, we define $f_P$ and $f_Q$ as
\begin{align*}
  f_P(s_P, s_Q) = & \{(s_P', L_Q') | s_P \xrightarrow{a} s_P', 
  L_Q=\{ s_Q' | s_Q \xrightarrow{a} s_Q'\}\} \\
  \cup & \{(s_P', L_Q') | s_P \xrightarrow{\epsilon} s_P', 
  L_Q=\{ s_Q' | s_Q \xrightarrow{\epsilon} s_Q'\}\} \\
  f_Q(s_P, s_Q) = & \{(L_P', s_Q') | s_Q \xrightarrow{a} s_Q', 
  L_P=\{ s_P' | s_P \xrightarrow{a} s_P'\}\} \\
  \cup & \{(L_P', s_Q') | s_Q \xrightarrow{\epsilon} s_Q', 
  L_P=\{ s_P' | s_P \xrightarrow{\epsilon} s_P'\}\} 
\end{align*}

For TadB, we define $f_P$ and $f_Q$ as
\begin{align*}
  f_P(s_P, s_Q) = & \{(s_P', L_Q') | s_P \xrightarrow{a} s_P', 
  L_Q=\{ s_Q' | s_Q \xrightarrow{\epsilon}\xrightarrow{a} s_Q'\}\} \\
  \cup & \{(s_P', L_Q') | s_P \xrightarrow{\epsilon} s_P', 
  L_Q=\{ s_Q' | s_Q \xrightarrow{\epsilon} s_Q'\}\} \\
  f_Q(s_P, s_Q) = & \{(L_P', s_Q') | s_Q \xrightarrow{a} s_Q', 
  L_P=\{ s_P' | s_P \xrightarrow{\epsilon}\xrightarrow{a} s_P'\}\} \\
  \cup & \{(L_P', s_Q') | s_Q \xrightarrow{\epsilon} s_Q', 
  L_P=\{ s_P' | s_P \xrightarrow{\epsilon} s_P'\}\} 
\end{align*}

For TaoB, we define $f_P$ and $f_Q$ as
\begin{align*}
  f_P(s_P, s_Q) = & \{(s_P', L_Q') | s_P \xrightarrow{a} s_P', 
  L_Q=\{ s_Q' | s_Q \xrightarrow{\epsilon}\xrightarrow{a}\xrightarrow{\epsilon} s_Q'\}\} \\
  \cup & \{(s_P', L_Q') | s_P \xrightarrow{\epsilon} s_P', 
  L_Q=\{ s_Q' | s_Q \xrightarrow{\epsilon} s_Q'\}\} \\
  f_Q(s_P, s_Q) = & \{(L_P', s_Q') | s_Q \xrightarrow{a} s_Q', 
  L_P=\{ s_P' | s_P \xrightarrow{\epsilon}\xrightarrow{a}\xrightarrow{\epsilon} s_P'\}\} \\
  \cup & \{(L_P', s_Q') | s_Q \xrightarrow{\epsilon} s_Q', 
  L_P=\{ s_P' | s_P \xrightarrow{\epsilon} s_P'\}\} 
\end{align*}

This formulation naturally suggests an approach: use tables to store
pairs of states in the two timed automata which are known to be
related or known to be unrelated, and use a dynamic programming
approach to verify the relation for any given pair of
states. Pseudocode for this is given in the
procedure~\ref{algorithm:checkautomatarelation} which calls
procedure~\ref{algorithm:checkstatesrelation} recursively to return
either \texttt{true} or \texttt{false} for the given pair of automata.

\begin{procedure}[H]
  \caption{CheckStatesRelation($P$, $Q$, $s_{P}$, $s_{Q}$,
    $yes\_ table$, $no\_ table$)}
  \label{algorithm:checkstatesrelation}
  \SetKwFunction{lookup}{lookup}
  \SetKwFunction{insert}{insert}
  \SetKwFunction{remove}{remove}
  \Begin{
      \eIf{\lookup{$yes\_ table$, $s_{P}$, $s_{Q}$}}{
        \KwRet true\;
      }{
        \eIf{\lookup{$yes\_ table$, $s_{P}$, $s_{Q}$}}{
          \KwRet false\;
        }{
          \insert{$yes\_ table$, $s_{P}$, $s_{Q}$}\;
          Set $v_P$\;
          \ForEach{$(s_P', L_Q')$ in $f_P(s_P, s_Q)$}{
            Reset $v_P$\;
            \ForEach{$s_Q'$ in $L_Q'$}{
              \If{\CheckStatesRelation{$P$, $Q$, $s_{P}'$, $s_{Q}'$,
                  $yes\_ table$, $no\_ table$}}{
                Set $v_P$\;
              }
            }
          }
          Set $v_Q$\;
          \ForEach{$(s_Q', L_P')$ in $f_Q(s_P, s_Q)$}{
            Reset $v_Q$\;
            \ForEach{$s_P'$ in $L_P'$}{
              \If{\CheckStatesRelation{$P$, $Q$, $s_{P}'$, $s_{Q}'$,
                  $yes\_ table$, $no\_ table$}}{
                Set $v_Q$\;
              }
            }
          }
          \eIf{$v_P$ $\wedge$ $v_Q$}{
            \KwRet true\;
          }{
            \remove{$yes\_ table$, $s_{P}$, $s_{Q}$}\;
            \insert{$yes\_ table$, $s_{P}$, $s_{Q}$}\;
            \KwRet false\;
          }
        }
      }
    }

\end{procedure}

\begin{procedure}[H]
  \caption{CheckAutomataRelation($T_P$, $T_Q$)}
  \label{algorithm:checkautomatarelation}
  \SetKwFunction{CheckStatesRelation}{CheckStatesRelation}
  \Begin{
      Create zone valuation graphs $G_P$, $G_Q$ of $T_P$, $T_Q$\;
      Find the zone $s_P$ in $G_P$ which contains the initial
      state of $T_P$\;
      Find the zone $s_Q$ in $G_Q$ which contains the initial
      state of $T_Q$\;
      Initialise $yes\_ table$ and $no\_ table$ to empty tables\;
      \KwRet \CheckStatesRelation{$G_P$, $G_Q$, $s_P$, $s_Q$,
        $yes\_ table$, $no\_ table$}\;
    }
\end{procedure}

