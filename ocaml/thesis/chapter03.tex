\chapter{Timed automata and relations on them}

\section{Clocks, valuations and related operations}

The timing model we use relies on the notions of clocks and
valuations. The timing information about the possible executions of a
timed automaton can, intuitively, be expressed in terms of constraints
on clocks. We will make this idea more precise as we go on.

\begin{definition}
\emph{Clock}: A clock is a variable ranging over the set of
non-negative real numbers, $R_{\geq 0}$.
\end{definition}

\begin{definition}
\emph{Valuation}: A valuation over a set of clocks $C$ is a
function $C \rightarrow R_{\geq 0}$, assigning non-negative values
to each of the clocks.
\end{definition}

Two important operations on clock valuations are clock resets and
delays. For a subset $X$ of $C$, the clock reset of a valuation $v$
is given by
\begin{displaymath}
  v[X:=0](x) = 
  \begin{cases}
    0    & \text{if } x \epsilon X \\
    v(x) & \text{if } x \epsilon C - X
  \end{cases}
\end{displaymath}

For a real delay $d$ $\epsilon$ $R_{\geq 0}$, the delay of a valuation
$v$ is given by
\begin{displaymath}
  (v + d)(x) = v(x) + d \quad \forall x \epsilon C
\end{displaymath}

\begin{definition}
\emph{Hyperplane}: Expressions of the forms $x \smile c$ and $x - y
\smile c$, where $x, y \epsilon C$, c is an integer, and $\smile
\epsilon \{ <, \leq, \geq, >\}$ are known as \emph{atomic clock
  constraints}. A valuation $v$ over $C$ is said to satisfy the
atomic clock constraint $x \smile c$ if $v(x) \smile c$ and $x - y
\smile c$ if $v(x) - v(y) \smile c$. A hyperplane is a set of
valuations satisfying an atomic clock constraint.
\end{definition}

\begin{definition}
\emph{Polyhedron}: The set of polyhedra over a set of clocks $C$ is
the smallest subset of the set of all valuations over $C$ that 
\begin{itemize}
\item contains all hyperplanes over C
\item is closed over intersection, union and complementation.
\end{itemize}
\end{definition}

\begin{definition}
\emph{Convex polyhedron}: A convex polyhedron is a polyhedron that can
be represented as the intersection of a set of hyperplanes.
\end{definition}

It should be noted that this definition does not coincide exactly with
the notion of a convex set from algebra. For instance, for
$C=\{x_1, x_2\}$, the set $\{(x_1, x_2)| x_1 \geq 0, x_2 \geq 0, x_1 +
x_2 > 0\}$ is convex but not a convex polyhedron.

Union, intersection, complementation and set difference are well
defined operations on polyhedra, but of these, intersection is the
only operation which preserves convexity.

The \emph{pre-reset} and \emph{post-reset} of a set $X$ $\epsilon$ $C$ on a
polyhedron $\zeta$ over the set $C$ of clocks are respectively defined
by
\begin{align*}
[X := 0]\zeta &= \{v| v[X := 0] \epsilon \zeta \} \\
\zeta[X := 0] &= \{v[X := 0]| v \epsilon \zeta \}
\end{align*}

The \emph{future} of a polyhedron $\zeta$ over a set $C$ of clocks
is given by 
\begin{displaymath}
\zeta \uparrow = \{v + d| v \epsilon \zeta, d \epsilon R_{\geq 0}\}
\end{displaymath}

The operators intersection, future, pre-reset, post-reset and future
preserve convexity of polyhedra.

\begin{definition}
\emph{Clock constraint}: A clock constraint is a polyhedron which can
be expressed as an intersection of hyperplanes of the form $x \smile
c$.
\end{definition}

A related term, \emph{extended clock constraint}, can be used
interchangeably with \emph{polyhedron}.

\section{Timed automata}

\begin{SCfigure}
  \centering
  \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node
      distance=2.8cm,
      semithick]
    \tikzstyle{every state}=[fill=red,draw=none,text=white]

    \node[initial,state] (A)                    {$q_a$};
    \node[state]         (B) [below of=A] {$q_b$};
    \node[state]         (C) [below of=B] {$q_c$};
    
    \path (A) edge              node {press, $x:=0$}    (B)
    (B) edge [bend left] node {press, $x > 1.4$}        (A)
    edge              node {press, $x \le 1.4$}         (C)
    (C) edge [bend right] node {press}                  (A);
  \end{tikzpicture}

  \caption{Timed automaton representing a light bulb with two
    brightness settings, example taken from \cite{aceto2007reactive}}
\end{SCfigure}

\begin{definition}
  \emph{Timed Automaton}: A timed automaton
  \cite{Alur94atheory} over a finite set of clocks $C$
  and a finite set of actions $Act$ is a 4-tuple $(L, l_{0}, E, I)$.
  \begin{itemize}
  \item $L$ is a finite set of locations.
  \item $l_{0}$ is the initial location.
  \item $E \subseteq L \times B(C) \times Act \times 2^{C} \times L$
    is a finite set of edges.
  \item $I: L \rightarrow B(C)$ assigns invariants to each edge
    location.
  \item $B(C)$ is the set of clock constraints over C.
  \end{itemize}
\end{definition}

This is a useful formalism for describing the behaviour of a system
with timing requirements on its behaviour. For a better understanding
of its semantics, it is useful to describe a labeled transition system
corresponding to it (called a timed LTS, or TLTS) that describes the
behaviour of this timed automaton.

\begin{definition}
  \emph{Timed LTS}: We define the timed LTS $T(A)$ defined by a timed
  automaton $(L, l_{0}, E, I)$ over a set of clocks $C$ and a set of
  actions $Act$ as 
  \begin{displaymath}
    T(A) = (Proc, Lab, \rightarrow)
  \end{displaymath}
  where
  \begin{itemize}
  \item $Proc = \{(l, v) | l$ $\epsilon$ $L, v$ $\epsilon$ $I(l)\}$
  \item $Lab = Act \cup R_{\ge 0}$
  \item $\rightarrow$ is given by
    \begin{itemize}
    \item $(l, v) \xrightarrow{a} (l', v')$ iff $a$ $\epsilon$ $Act$, $\exists (l
      \xrightarrow{g, a, r} l')$ $\epsilon$ $E$ such that $v$ $\models$
      $g$ $\wedge$ $v'=v[r:=0]$ $\wedge$ $v'$ $\models$ $I(l')$
    \item $(l, v) \xrightarrow{d} (l, v')$ iff $d$ $\epsilon$ $R_{\ge
      0}$ $\wedge$ $v$ $\models$ $I(l)$ $\wedge$ $v'$ $\models$ $I(l)$
    \end{itemize}
  \end{itemize}

\end{definition}

We will use the object-oriented notation \texttt{l.invar} to refer to
the invariant $I(l)$ of a location $l$ and \texttt{e.source}, \texttt{e.guard},
\texttt{e.action}, \texttt{e.resets} and \texttt{e.target} to refer to
$l$, $g$, $a$, $r$, $l'$ of
an edge $e = l \xrightarrow{g, a, r} l'$ unless otherwise noted.

\section{Region graphs}

\begin{figure}
  \centering
  \caption{Motivating examples for region graphs.}

  \begin{subfigure}[b]{0.6\textwidth}
    \centering
    \def\svgwidth{\columnwidth}
    \input{regiongraph01.pdf_tex}
    \caption{}
    \label{regiongraph01}
  \end{subfigure}%
  ~%add desired spacing between images, e. g. ~, \quad, \qquad
  %etc.
  %(or a blank line to force the subfigure onto a new line)
  \begin{subfigure}[b]{0.2\textwidth}
    \centering
    \def\svgwidth{\columnwidth}
    \input{regiongraph02.pdf_tex}
    \caption{}
    \label{regiongraph02}
  \end{subfigure}

\end{figure}

The notion of a region graph was first introduced in
\cite{Alur94atheory} and used to show that discretisation of the state
space of a timed automaton is decidable under a certain abstraction of
exact timing values while examining the possible states and actions of
a timed automaton.

To motivate this, we should note that in figure~\ref{regiongraph01}, we can distinguish
between the valuations $[X = 1.1]$, $[X = 2.0]$ and $[X = 2.2]$ at
location 0 on the
basis of the possibility of their outgoing a-transitions: the first can
only move to 1, the second can move to 1 and 2, and the third can move
to 1, 2, and 3.

Also, in figure~\ref{regiongraph02}, we can distinguish between
valuations $[X = 0.6, Y = 0.4]$ and $[X = 0.4; Y = 0.6]$ at location 0
since the first can take a delay of 0.4 units, then an a-transition to
1, then a delay of 0.2, then an a-transition to 2, but the second
cannot move to 2 since it must take a delay of 0.6 to move to 1 which
leaves no possibility of it moving to 2 after any amount of delay.

For each clock $x$, we define $c_x$ to be the
greatest constant compared to x over all guards and invariants in the
automaton. It is evident that any two valuations which both assign
values greater than $c_x$ to $x$ should not be distinguished, but we should
distinguish between valuations differing in $\lfloor v(x)\rfloor$ $x$
for any clock $x$, between valuations having the same $v(x)$
but in which one has $frac(v(x))=0$ but the other does not,
and between valuations which have different relative orderings of
$v(x)$ and $v(y)$ for any pair of clocks $(x, y)$. We formalise these
notions in this definition.

\begin{definition}
  \emph{Region graph}: A region graph is a partitioning of the set of
  valuations for a given timed automaton into equivalence
  classes under \emph{region equivalence}.

  Valuations $v_1$ and $v_2$ are related under region equivalence if 
  \begin{itemize}
    \item $\forall x$ $\epsilon$ $C$: $(\lfloor v_1(x) \rfloor = \lfloor
      v_2(x) \rfloor) \leq c_x$ or $v_1(x) > c_x$ and $v_2(x) > c_x$ .
    \item $\forall x$ $\epsilon$ $C$: $v_1(x) = 0$ iff $v_2(x) = 0$.
    \item $\forall$ pairs of clocks $(x, y)$: $frac(v_1(x)) \leq
      frac(v_1(y))$ iff $frac(v_2(x)) \leq frac(v_2(y))$.
  \end{itemize}
\end{definition}

It is evident that any two states sharing a location and satisfying
region equivalence of their states are going to, under an abstraction
of exact values of time delays (a notion we will formalise in
\ref{def:stab}). This result is important as it shows that there are
finitely many categories of states (which we will talk about in
\ref{def:zone}) which we need to consider.

\section{Zone graphs}

It is evident that the state space in a timed automaton is, in
general, uncountably infinite. However, we have seen that region
graphs can be used to make the state space finite, but at the cost of
state explosion, since the number of regions is generally exponential
in the number of clocks. Some alternative, less expensive methods for
discretising the state space follow.

\begin{definition}
  \emph{State}: A state of a timed automaton is a pair $(l, v)$
  where $l$ is a location in the automaton and $v$ is a clock
  valuation satisfying \texttt{l.invar}.
\end{definition}

\begin{definition}
  \emph{Symbolic state}: A symbolic state is a set of states in
  the timed automaton. The constituent states do not necessarily share
  a location.
\end{definition}

\begin{definition}
\label{def:zone}
  \emph{Zone}: A zone is a symbolic state where the all the
  constituent states share a location and the set of valuations of
  these states forms a convex polyhedron on the valuation space.
\end{definition}

\begin{definition}
  \emph{Zone graph}: A zone graph of a timed automaton is an LTS, where
  the states are zones, the actions consist of the actions of the
  timed automaton and an $\epsilon$ action, which represents a timed
  transition, and the transition relation respects the invariants,
  guards and clock resets of the original timed automaton.
\end{definition}

\section{Difference bound matrices}
\begin{definition}
  \emph{Difference bound matrix}: A difference bound matrix (DBM) is a
  representation of a convex polyhedron on a set of clocks $\{x_{1},
  \ldots x_{n}\}$ in the form of an $(n+1) \times (n+1)$
  matrix $M$, each element of which takes the form $(m_{ij}, \smile
  _{ij})$, where $m_{ij}$ is an integer and $\smile_{ij}$ $\epsilon$
  $\{ <, \leq\}$. Assuming $x_0$ to be a clock always valued at zero,
  the associated polyhedron is given by
  \begin{displaymath}
    \bigcap_{0 \leq i, j \leq n}(x_{i} - x_{j} \smile_{ij} m_{ij})
  \end{displaymath}
\end{definition}

DBM offer a convenient method to represent polyhedra for most of the
common operations required on zones, including intersection, clock
resets, future, and abstraction. The UPPAAL DBM libraries
\cite{david2006uppaal} \cite{bengtsson2004timed} implement many common
functions on DBM and have been extensively used in our implementation.
% elaborate on the operations for DBM.

\section{Abstraction}

\begin{figure}
  \centering
  \caption{Timed automaton with a potentially infinite
    set of zones, example taken from \cite{Behrmann03staticguard}.}
  \label{breaking2withzones}
  \begin{subfigure}[b]{0.5\textwidth}
    \centering
    \def\svgwidth{\columnwidth}
    \input{breaking2.pdf_tex}
    \caption{Timed automaton with potentially infinite state space.}
    \label{breaking2}
  \end{subfigure}%
  %add desired spacing between images, e. g. ~, \quad, \qquad
  %etc.
  %(or a blank line to force the subfigure onto a new line)

  \begin{subfigure}[b]{0.3\textwidth}
    \centering
    \def\svgwidth{\columnwidth}
    \input{breaking2-zones01.pdf_tex}
    \caption{Zones of Figure~\ref{breaking2} after 1 iteration.}
    \label{breaking2-zones01}
  \end{subfigure}
  ~ %add desired spacing between images, e. g. ~, \quad, \qquad
  %etc.
  %(or a blank line to force the subfigure onto a new line)
  \begin{subfigure}[b]{0.6\textwidth}
    \centering
    \def\svgwidth{\columnwidth}
    \input{breaking2-zones02.pdf_tex}
    \caption{Zones of Figure~\ref{breaking2} after 2 iterations.}
    \label{breaking2-zones02}
  \end{subfigure}
  %add desired spacing between images, e. g. ~, \quad, \qquad
  %etc.
  %(or a blank line to force the subfigure onto a new line)

  \begin{subfigure}[b]{\textwidth}
    \centering
    \def\svgwidth{0.9\columnwidth}
    \input{breaking2-zones03.pdf_tex}
    \caption{Zones of Figure~\ref{breaking2} after 3 iterations.}
    \label{breaking2-zones03}
  \end{subfigure}
\end{figure}

\begin{figure}
  \centering
  \def\svgwidth{0.9\columnwidth}
  \input{breaking2-zones-abstracted.pdf_tex}
  \caption{Zones of Figure~\ref{breaking2} after abstraction.}
\end{figure}

A common feature of algorithms that generate zone graphs for timed
automata is a \emph{forward propagation} step in which the algorithm attempts to
create reachable zones in reachable locations by traversing the timed
automaton. However, this introduces a vulnerability to certain
pathological cases in which the number of zones expands indefinitely,
preventing termination of the algorithm. For example, in the automaton in
Figure~\ref{breaking2}, the number of zones may expand in each
iteration, as shown in Figure~\ref{breaking2-zones01},
Figure~\ref{breaking2-zones02}, Figure~\ref{breaking2-zones03}.

However, this is inconsistent with what
we know about region graphs and their
implication of finiteness for the state spaces of timed automata,
thus, we have abstractions which serve to cap the number of zones in a
zone graph by reducing zones to equivalent regions which contain them,
thus ensuring termination of zone creation algorithms.

In this implementation we use a simplified version of the
\emph{maximum constants} abstraction described in
\cite{Behrmann03staticguard}.

Algebraically, our abstraction can be thus described: given a set of
clocks $\{x_i | 1 \leq i \leq n \}$, a maximum constant $k$ over all
clocks, and a DBM $M = \langle (m_{ij}, \smile _{ij})\rangle _{0 \leq
  i,j \leq n} $, we can replace $M$ with $M' = \langle m'_{ij}, \smile
'_{ij}\rangle _{0 \leq i,j \leq n} $ where
\begin{displaymath}
  (m'_{ij}, \smile'_{ij}) =
    \begin{cases}
      (\infty, <)  & \mbox{if } m_{ij} > k \\
      (-k, <)  & \mbox{if } m_{ij} < -k \\
      m_{ij}, \smile _{ij} & \mbox{if } -k \leq m_{ij} \leq k
    \end{cases}
\end{displaymath}

\section{Time abstracted relations on timed automata}

\subsection{Time abstracted bisimilarity}

\begin{figure}
  \centering
  \caption{Examples for time abstracted bisimilarities.}
  \label{fig:tab}

  \begin{subfigure}[b]{0.2\textwidth}
    \centering
    \def\svgwidth{\columnwidth}
    \input{pair01first.pdf_tex}
    \caption{}
    \label{pair01first}
  \end{subfigure}%
  ~%add desired spacing between images, e. g. ~, \quad, \qquad
  %etc.
  %(or a blank line to force the subfigure onto a new line)
  \begin{subfigure}[b]{0.2\textwidth}
    \centering
    \def\svgwidth{\columnwidth}
    \input{pair01second.pdf_tex}
    \caption{}
    \label{pair01second}
  \end{subfigure}
  %add desired spacing between images, e. g. ~, \quad, \qquad
  %etc.
  %(or a blank line to force the subfigure onto a new line)

  \begin{subfigure}[b]{0.2\textwidth}
    \centering
    \def\svgwidth{\columnwidth}
    \input{pair02first.pdf_tex}
    \caption{}
    \label{pair02first}
  \end{subfigure}
  ~%add desired spacing between images, e. g. ~, \quad, \qquad
  %etc.
  %(or a blank line to force the subfigure onto a new line)
  \begin{subfigure}[b]{0.2\textwidth}
    \centering
    \def\svgwidth{\columnwidth}
    \input{pair02second.pdf_tex}
    \caption{}
    \label{pair02second}
  \end{subfigure}

  \begin{subfigure}[b]{0.4\textwidth}
    \centering
    \def\svgwidth{\columnwidth}
    \input{pair03first.pdf_tex}
    \caption{}
    \label{pair03first}
  \end{subfigure}
  ~%add desired spacing between images, e. g. ~, \quad, \qquad
  %etc.
  %(or a blank line to force the subfigure onto a new line)
  \begin{subfigure}[b]{0.4\textwidth}
    \centering
    \def\svgwidth{\columnwidth}
    \input{pair03second.pdf_tex}
    \caption{}
    \label{pair03second}
  \end{subfigure}

\end{figure}

\begin{definition} 
\label{def:stab} 
  \emph{Strong time abstracted bisimulation}: A binary relation
  $R$ is a strong time abstracted bisimulation (STaB) if and only if, for all
  $(s_1, s_2)$ $\epsilon$ $R$ , $a$ $\epsilon$ $Act $, $d$ $\epsilon$ $R_{\ge 0}$\\
  $\forall s_1' (s_1 \xrightarrow{a} s_1' \Rightarrow \exists s_2'
  . (s_2 \xrightarrow{a} s_2' \wedge (s_1', s_2')$ $\epsilon$ $R ) )
  \wedge $ \\
  $\forall s_2' (s_2 \xrightarrow{a} s_2' \Rightarrow \exists s_1'
  . (s_1 \xrightarrow{a} s_1' \wedge (s_1', s_2')$ $\epsilon$ $R ) ) \wedge $ \\
  $\forall s_1' (s_1 \xrightarrow{d} s_1' \Rightarrow \exists (s_2',
  d')
  . (s_2 \xrightarrow{d'} s_2' \wedge (s_1', s_2')$ $\epsilon$ $R ) )
  \wedge $ \\
  $\forall s_2' (s_2 \xrightarrow{d} s_2' \Rightarrow \exists (s_1', d')
  . (s_1 \xrightarrow{d'} s_1' \wedge (s_1', s_2')$ $\epsilon$ $R ) ) $ \\
\end{definition}

It can be shown that the union of all strong time abstracted
  bisimulations over the set of (location, valuation) pairs is a
  strong time abstracted bisimulation. This binary relation is called
  \textit{strong time abstracted bisimilarity}.

\begin{definition}
  \emph{Time abstracted delay bisimulation}: A binary relation
  $R$ is a time abstracted delay bisimulation (TadB) if and only if, for all
  $(s_1, s_2)$ $\epsilon$ $R$ , $a$ $\epsilon$ $Act $, $d$ $\epsilon$ $R_{\ge 0}$\\
  $\forall s_1' (s_1 \xrightarrow{a} s_1' \Rightarrow \exists (s_2', d)
  . (s_2 \xrightarrow{d} \xrightarrow{a} s_2' \wedge (s_1', s_2')$ $\epsilon$ $R ) )
  \wedge $ \\
  $\forall s_2' (s_2 \xrightarrow{a} s_2' \Rightarrow \exists (s_1', d)
  . (s_1 \xrightarrow{d} \xrightarrow{a} s_1' \wedge (s_1', s_2')$
  $\epsilon$ $R ) ) 
  \wedge $ \\
  $\forall s_1' (s_1 \xrightarrow{d} s_1' \Rightarrow \exists (s_2',
  d')
  . (s_2 \xrightarrow{d'} s_2' \wedge (s_1', s_2')$ $\epsilon$ $R ) )
  \wedge $ \\
  $\forall s_2' (s_2 \xrightarrow{d} s_2' \Rightarrow \exists (s_1', d')
  . (s_1 \xrightarrow{d'} s_1' \wedge (s_1', s_2')$ $\epsilon$ $R ) ) $ \\
\end{definition}

It can be shown that the
  union of all time abstracted delay bisimulations over the set of
  (location, valuation) pairs is a time abstracted delay
  bisimulation. This binary relation is called \textit{time abstracted
    delay bisimilarity}.

\begin{definition}
  \emph{Time abstracted observational bisimulation}: A binary relation
  $R$ is a time abstracted observational bisimulation (TaoB) if and only if, for all
  $(s_1, s_2)$ $\epsilon$ $R$ , $a$ $\epsilon$ $Act $, $d$ $\epsilon$ $R_{\ge 0}$\\
  $\forall s_1' (s_1 \xrightarrow{a} s_1' \Rightarrow \exists (s_2',
  d, d') . (s_2 \xrightarrow{d} \xrightarrow{a} \xrightarrow{d'} s_2'
  \wedge (s_1', s_2')$ $\epsilon$ $R ) ) \wedge $ \\
  $\forall s_2' (s_2 \xrightarrow{a} s_2' \Rightarrow \exists (s_1',
  d, d') . (s_1 \xrightarrow{d} \xrightarrow{a} \xrightarrow{d'} s_1'
  \wedge (s_1', s_2')$ $\epsilon$ $R ) ) \wedge $ \\
  $\forall s_1' (s_1 \xrightarrow{d} s_1' \Rightarrow \exists (s_2',
  d')
  . (s_2 \xrightarrow{d'} s_2' \wedge (s_1', s_2')$ $\epsilon$ $R ) )
  \wedge $ \\
  $\forall s_2' (s_2 \xrightarrow{d} s_2' \Rightarrow \exists (s_1', d')
  . (s_1 \xrightarrow{d'} s_1' \wedge (s_1', s_2')$ $\epsilon$ $R ) ) $ \\
\end{definition}

It can be shown that
  the union of all time abstracted observational bisimulations over the
  set of (location, valuation) pairs is a time abstracted observational
  bisimulation. This binary relation is called \textit{time abstracted
    observational bisimilarity}.

Figure~\ref{fig:tab} shows examples for each kind of time abstracted
bisimilarity. The initial zones of Figure~\ref{pair01first} and
Figure~\ref{pair01second} show STaB, TadB and TaoB, while the initial
zones of Figure~\ref{pair02first} and Figure~\ref{pair02second} show
TadB and TaoB but not STaB, and the initial zones of Figure~\ref{pair03first} and
Figure~\ref{pair03second} show TaoB but not STaB or TadB.
