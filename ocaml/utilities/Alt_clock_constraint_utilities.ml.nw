\subsection{Alt\_clock\_constraint\_utilities.ml}
This file provides some important operations on clock constraints (the
older kind.)

<<Alt_clock_constraint_utilities.ml>>=
open Alt_grammar_types
open Alt_UDBM_utilities

module TA = Timed_automaton

@ 
\begin{itemize}
\item This function turns a clock constraint (in the old
  representation) into a string.
<<Alt_clock_constraint_utilities.ml>>=
let string_of_clock_constraint clock_constraint =
  (String.concat
     " AND "
     (List.map
        (function
        | True -> "TRUE"
        | False -> "FALSE"
        | Lt (cn, n) -> cn ^ " < " ^ (string_of_int n)
        | Le (cn, n) -> cn ^ " <= " ^ (string_of_int n)
        | Eq (cn, n) -> cn ^ " = " ^ (string_of_int n)
        | Ge (cn, n) -> cn ^ " >= " ^ (string_of_int n)
        | Gt (cn, n) -> cn ^ " > " ^ (string_of_int n)
        )
        clock_constraint
     )
  )
    
@ 
\item This function kind of implements the pre-reset operation, with
the rider that the zero-ness of the clocks in question is not checked.
<<Alt_clock_constraint_utilities.ml>>=
let clock_constraint_without_reset_clocks
    clock_constraint
    clock_resets =
  String_set.fold
    (function clock_name -> function clock_constraint ->
      List.filter
        (function
        | True
        | False -> true
        | Lt (cn, _)
        | Le (cn, _)
        | Eq (cn, _)
        | Ge (cn, _)
        | Gt (cn, _) -> cn <> clock_name
        )
        clock_constraint
    )
    clock_resets
    clock_constraint

@ 
\item This function  implements the post-reset operation.
<<Alt_clock_constraint_utilities.ml>>=
let clock_constraint_after_clock_resets
    clock_constraint
    clock_resets =
  (List.map
     (function clock_reset -> Eq (clock_reset, 0))
     (String_set.elements clock_resets)
  )
  @
    (clock_constraint_without_reset_clocks
       clock_constraint
       clock_resets)

@ 
\item This function finds the maximum constant in the timed automaton
for use in abstractions.
<<Alt_clock_constraint_utilities.ml>>=
let maximum_constant ta =
  let
      f clock_constraint =
    List.fold_left
      (function max ->
        function
        | True
        | False -> max
        | Lt (_, n)
        | Le (_, n)
        | Eq (_, n)
        | Ge (_, n)
        | Gt (_, n) -> if max > n then max else n
      )
      0
      clock_constraint
  in
  Location_graph.fold_vertex
    (function location -> function max ->
      Location_graph.fold_succ_e
        (function departure -> function max -> 
          if
            (max > f (Location_graph.E.label departure).condition)
          then
            max
          else
            (f (Location_graph.E.label departure).condition) 
        )
        (TA.get_location_graph ta)
        location
        (if
            (max >
               f (Location_invariant_map.find location
                    (TA.get_location_invariant_map ta))
            )
         then
            max
         else
            f (Location_invariant_map.find location
                    (TA.get_location_invariant_map ta))
        )
    )
    (TA.get_location_graph ta)
    0
  
@ 
\end{itemize}

<<Alt_clock_constraint_utilities.ml>>=
module Test = 
struct
  let test19 =
    if
      [Eq ("X1", 0); Eq ("X3", 0); Gt ("X2", 3); Lt
        ("X2", 5)]
      =
      (clock_constraint_after_clock_resets
         [Ge ("X1", 5); Gt ("X2", 3); Le ("X1", 7); Lt ("X3", 5); Lt
           ("X2", 5)]
         (List.fold_right String_set.add ["X1"; "X3"] String_set.empty))
    then
      "test19 passed"
    else
      "test19 failed"
end
