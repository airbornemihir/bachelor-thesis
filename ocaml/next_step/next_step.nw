\begin{itemize}

<<next_step.ml>>=
open Grammar_types
open Parse_timed_automaton
open Clock_utilities

let display_state state = 
  print_string("location = ");
  print_int state.location.location_index;
  print_newline();
  Valuation.iter
    (function clock_name ->
      (function clock_value ->
	print_string("clock_name = " ^ clock_name ^
			", clock_value = ");
	print_float(clock_value);
	print_newline()
      )
    )
    state.valuation

@ 
\item This function returns a boolean value denoting whether or not
  the valuation satisfies the proposition
  given the constraints of this automaton.
<<next_step.ml>>=
let rec satisfies ta valuation proposition = match proposition with
    True -> true
  | False -> false
  | Comparison (cn, cmpr, n) -> (match cmpr with
    Lt -> ((Valuation.find cn valuation) <
			    float_of_int(n))
    | Le -> ((Valuation.find cn valuation) <=
			    float_of_int(n))
    | Eq -> ((Valuation.find cn valuation) =
			    float_of_int(n))
    | Ge -> ((Valuation.find cn valuation) >=
			    float_of_int(n))
    | Gt -> ((Valuation.find cn valuation) >
			    float_of_int(n))
  )
  | And propl -> List.fold_left (function satisfaction ->
    (function next_proposition  -> satisfaction && (satisfies ta valuation
    next_proposition))) true propl

@ 
\item This function returns a list containing all the 
  states that the timed automaton can go to instantaneously from this
  state.
<<next_step.ml>>=
let can_jump_to ta state =
  (let
      (location, valuation) = (state.location, state.valuation)
   in
   let
      departures = location.departures
   in
   let
       possible_departures =  (List.filter
     (function transition -> (satisfies ta valuation transition.condition))
     (Array.to_list departures))
   in
   let
       possible_arrivals = (List.map
     (function transition ->
       {
       location = ta.locations.(transition.next_location)
       ;
       valuation = reset_clocks valuation (Array.to_list transition.clock_resets)
       }
     ) 
     possible_departures)
   in
   let
       possible_retentions = (List.filter
   (function state -> satisfies ta valuation state.location.invariant)
   possible_arrivals)
   in
   possible_retentions
  )

@ 
\item This shows whether or not a particular state of a timed
  automaton can accept a delay without violating the invariant.

<<next_step.ml>>=
let can_stay_in ta state duration =
  satisfies
    ta
    (add_delay
       state.valuation
       duration
    )
    state.location.invariant

let _ =
  let result = parse_timed_automaton stdin in
  let
      initstate = 
    {location = result.locations.(result.numinit);
     valuation = add_delay (zero_valuation result) 2.0}
  in
  display_state initstate;
  let a =
    Array.of_list
      (can_jump_to
	 result
	 initstate
      )
  in
  let len = Array.length a
  in
  for i = 0 to len - 1 do
    display_state a.(i);
  done;
  flush stdout;
  exit 0

@ 
\end{itemize}
