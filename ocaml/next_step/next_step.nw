\begin{itemize}

<<next_step.ml>>=
include Grammar_typesn
(* open Grammar_types *)
open Parse_timed_automaton

@ 
\item This function creates a valuation for the given timed automaton
  where all the clocks are set to zero.
<<next_step.ml>>=
let zero_valuation ta = List.fold_right (function clockname -> (function valuation
-> Valuation.add clockname 0.0 valuation)) (Array.to_list ta.clocknames) (Valuation.empty)

@ 
\item This function pushes all the clocks forward by a time delay.
<<next_step.ml>>=
let add_delay valuation delay = Valuation.map (function clock_value ->
  clock_value +. delay) valuation

@ 
\item This function resets the specified clocks.
<<next_step.ml>>=
  let reset_clocks valuation clocknamelist =
    List.fold_left
      (function valuation ->
	function clockname ->
	  if
	    Valuation.mem clockname valuation (*this should always be
						true, but who knows
						these days?*)
	  then
	    Valuation.add clockname 0.0 valuation
	  else
	    valuation
      )
      valuation
      clocknamelist

@ 
\item This function returns a boolean value denoting whether or not
  the valuation satisfies the proposition
  given the constraints of this automaton.
<<next_step.ml>>=
let rec f2 ta valuation proposition = match proposition with
    True -> true
  | False -> false
  | Comparison (cn, cmpr, n) -> (match cmpr with
    Lt -> ((Valuation.find cn valuation) <
			    float_of_int(n))
    | Le -> ((Valuation.find cn valuation) <=
			    float_of_int(n))
    | Eq -> ((Valuation.find cn valuation) =
			    float_of_int(n))
    | Ge -> ((Valuation.find cn valuation) >=
			    float_of_int(n))
    | Gt -> ((Valuation.find cn valuation) >
			    float_of_int(n))
  )
  | And propl -> List.fold_left (function satisfaction ->
    (function next_proposition  -> satisfaction && (f2 ta valuation
    next_proposition))) true propl

@ 
\item This function returns a list containing all the 
  locations that the function can go to instantaneously from this
  location and valuation pair.
<<next_step.ml>>=
let f1 ta (location, valuation) =
  (let
      departures = location.departures
   in
   let
       possible_departures =  (List.filter
     (function transition -> (f2 ta valuation transition.condition))
     (Array.to_list departures))
   in
   let
       possible_arrivals = (List.map
     (function transition ->
       (
       ta.locations.(transition.nextlocation)
       ,
       reset_clocks valuation (Array.to_list ta.clocknames)
       )
     ) 
     possible_departures)
   in
   let
       possible_retentions = (List.filter
   (function (location, _) -> f2 ta valuation location.invariant)
   possible_arrivals)
   in
   possible_retentions
  )

let _ =
  let result = parse_timed_automaton stdin in
  let a = Array.of_list (List.map
			   (function (location, _) -> location.locationindex)
			   (f1
			      result
			      (result.locations.(result.numinit), 
			       add_delay (zero_valuation result) 2.0)
			   )
  )
  in
  let len = Array.length a
  in
  for i = 0 to len - 1 do
    print_int a.(i);
    print_newline();
  done;
  flush stdout;
  exit 0

@ 
\end{itemize}

