\begin{itemize}

<<next_step.ml>>=
open Grammar_types
open Parse_timed_automaton

(* How the hell do we make this more global than it is now? *)
module Valuation = Map.Make (String)

@ 
\item This function creates a valuation for the given timed automaton
  where all the clocks are set to zero.
<<next_step.ml>>=
let zero_valuation ta = List.fold_right (function clockname -> (function valuation
-> Valuation.add clockname 0.0 valuation)) (Array.to_list ta.clocks) (Valuation.empty)

@ 
\item This function returns a boolean value denoting whether or not
  the valuation satisfies the proposition
  given the constraints of this automaton.
<<next_step.ml>>=
let rec f2 ta valuation proposition = match proposition with
    True -> true
  | False -> false
  | Comparison (cn, cmpr, n) -> (match cmpr with
    Lt -> ((Valuation.find cn valuation) <
			    float_of_int(n))
    | Le -> ((Valuation.find cn valuation) <=
			    float_of_int(n))
    | Eq -> ((Valuation.find cn valuation) =
			    float_of_int(n))
    | Ge -> ((Valuation.find cn valuation) >=
			    float_of_int(n))
    | Gt -> ((Valuation.find cn valuation) >
			    float_of_int(n))
  )
  | And propl -> List.fold_left (function satisfaction ->
    (function next_proposition  -> satisfaction && (f2 ta valuation
    next_proposition))) true propl

@ 
\item This function returns a list containing all the 
  locations that the function can go to instantaneously from this
  location and valuation pair.
<<next_step.ml>>=
let f1 ta valuation location =
  (let
      departures = location.departures
   in
   let
       possible_departures =  (List.filter
     (function transition -> (f2 ta valuation transition.condition))
     (Array.to_list departures))
   in
   let
       possible_arrivals = (List.map
     (function transition -> ta.locations.(transition.nextlocation))
     possible_departures)
   in
   let
       possible_retentions = (List.filter
   (function location -> (f2 ta valuation location.invariant))
   possible_arrivals)
   in
   possible_retentions
  )

@ 
\item This function pushes all the clocks forward by a time delay.
<<next_step.ml>>=
let add_delay valuation delay = Valuation.map (function clock_value ->
  clock_value +. delay) valuation

let _ =
  let result = parse_timed_automaton stdin in
  let a = Array.of_list (List.map
			   (function location -> location.locationindex)
			   (f1 (result) (add_delay (zero_valuation result) 2.0)
			      (result.locations.(result.numinit))))
  in
  let len = Array.length a
  in
  for i = 0 to len - 1 do
    print_int a.(i);
    print_newline();
  done;
  flush stdout;
  exit 0

@ 
\end{itemize}

