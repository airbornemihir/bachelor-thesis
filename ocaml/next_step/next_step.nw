\begin{itemize}

<<next_step.ml>>=
open Grammar_types
open Parse_timed_automaton

let display_state state = 
  print_string("location = ");
  print_int state.location.location_index;
  print_newline();
  Valuation.iter
    (function clock_name ->
      (function clock_value ->
	print_string("clock_name = " ^ clock_name ^
			", clock_value = ");
	print_float(clock_value);
	print_newline()
      )
    )
    state.valuation

@ 
\item This function creates a valuation for the given timed automaton
  where all the clocks are set to zero.
<<next_step.ml>>=
let zero_valuation ta = List.fold_right (function clock_name -> (function valuation
-> Valuation.add clock_name 0.0 valuation)) (Array.to_list ta.clock_names) (Valuation.empty)

@ 
\item This function pushes all the clocks forward by a time delay.
<<next_step.ml>>=
let add_delay valuation delay = Valuation.map (function clock_value ->
  clock_value +. delay) valuation

@ 
\item This function resets the specified clocks.
<<next_step.ml>>=
  let reset_clocks valuation clock_namelist =
    List.fold_left
      (function valuation ->
	function clock_name ->
	  if
	    Valuation.mem clock_name valuation (*this should always be
						 true, but who knows
						 these days?*)
	  then
	    Valuation.add clock_name 0.0 valuation
	  else
	    valuation
      )
      valuation
      clock_namelist

@ 
\item This function returns a boolean value denoting whether or not
  the valuation satisfies the proposition
  given the constraints of this automaton.
<<next_step.ml>>=
let rec satisfies ta valuation proposition = match proposition with
    True -> true
  | False -> false
  | Comparison (cn, cmpr, n) -> (match cmpr with
    Lt -> ((Valuation.find cn valuation) <
			    float_of_int(n))
    | Le -> ((Valuation.find cn valuation) <=
			    float_of_int(n))
    | Eq -> ((Valuation.find cn valuation) =
			    float_of_int(n))
    | Ge -> ((Valuation.find cn valuation) >=
			    float_of_int(n))
    | Gt -> ((Valuation.find cn valuation) >
			    float_of_int(n))
  )
  | And propl -> List.fold_left (function satisfaction ->
    (function next_proposition  -> satisfaction && (satisfies ta valuation
    next_proposition))) true propl

@ 
\item This function returns a list containing all the 
  states that the timed automaton can go to instantaneously from this
  state.
<<next_step.ml>>=
let f1 ta state =
  (let
      (location, valuation) = (state.location, state.valuation)
   in
   let
      departures = location.departures
   in
   let
       possible_departures =  (List.filter
     (function transition -> (satisfies ta valuation transition.condition))
     (Array.to_list departures))
   in
   let
       possible_arrivals = (List.map
     (function transition ->
       {
       location = ta.locations.(transition.next_location)
       ;
       valuation = reset_clocks valuation (Array.to_list transition.clock_resets)
       }
     ) 
     possible_departures)
   in
   let
       possible_retentions = (List.filter
   (function state -> satisfies ta valuation state.location.invariant)
   possible_arrivals)
   in
   possible_retentions
  )

let _ =
  let result = parse_timed_automaton stdin in
  let
      initstate = 
    {location = result.locations.(result.numinit);
     valuation = add_delay (zero_valuation result) 2.0}
  in
  display_state initstate;
  let a =
    Array.of_list
      (f1
	 result
	 initstate
      )
  in
  let len = Array.length a
  in
  for i = 0 to len - 1 do
    display_state a.(i);
  done;
  flush stdout;
  exit 0

@ 
\end{itemize}
