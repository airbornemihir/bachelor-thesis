\begin{itemize}

<<next_step.ml>>=

(* How the hell do we make this more global than it is now? *)
module Valuation = Map.Make (String)

@ 
\item This function creates a valuation for the given timed automaton
  where all the clocks are set to zero.
<<next_step.ml>>=
let zero_valuation ta = List.fold_right (function clock -> (function valuation
-> Valuation.add clock.Grammar_types.clockname 0.0 valuation)) (Array.to_list ta.Grammar_types.clocks) (Valuation.empty)

@ 
\item This function returns a boolean value denoting whether or not
  the valuation satisfies the proposition
  given the constraints of this automaton.
<<next_step.ml>>=
let rec f2 ta valuation proposition = match proposition with
    Grammar_types.True -> true
  | Grammar_types.False -> false
  | Grammar_types.Comparison (cn, cmpr, n) -> (match cmpr with
    Grammar_types.Lt -> ((Valuation.find cn valuation) <
			    float_of_int(n))
    | Grammar_types.Le -> ((Valuation.find cn valuation) <=
			    float_of_int(n))
    | Grammar_types.Eq -> ((Valuation.find cn valuation) =
			    float_of_int(n))
    | Grammar_types.Ge -> ((Valuation.find cn valuation) >=
			    float_of_int(n))
    | Grammar_types.Gt -> ((Valuation.find cn valuation) >
			    float_of_int(n))
  )
  | Grammar_types.And propl -> List.fold_left (function satisfaction ->
    (function next_proposition  -> satisfaction && (f2 ta valuation
    next_proposition))) true propl

@ 
\item This function returns a list containing all the 
  locations that the function can go to instantaneously from this
  location and valuation pair.
<<next_step.ml>>=
let f1 ta valuation location = List.filter (function
transition -> (f2 ta valuation transition.Grammar_types.condition))
  (Array.to_list (location.Grammar_types.departures))

@ 
\item This function pushes all the clocks forward by a time delay.
<<next_step.ml>>=
let add_delay valuation delay = Valuation.map (function clock_value ->
  clock_value +. delay) valuation

let _ =
  let lexbuf = Lexing.from_channel stdin in
  (let result = Parser.main Lexer.token lexbuf in
   (* print_int (result.Grammar_types.numlocations); *)
   (* print_newline(); *)
   (* print_int (result.Grammar_types.numtrans); *)
   (* print_newline(); *)
   (* print_int (result.Grammar_types.numclocks); *)
   (* print_newline(); *)
   (* print_int (result.Grammar_types.numinit); *)
   (* print_newline(); *)
   (* print_int (Array.length result.Grammar_types.clocks); *)
   (* print_newline(); *)
   (* print_int (Array.length result.Grammar_types.locations); *)
   (* print_newline(); *)
   let a = Array.of_list (f1 (result) (add_delay (zero_valuation result) 2.0)
			    (result.Grammar_types.locations.(result.Grammar_types.numinit)))
   in
   let len = Array.length a
   in
   for i = 0 to len - 1 do
     print_int (a.(i).Grammar_types.nextlocation);
     print_newline();
   done;
   flush stdout;
   exit 0)

@ 
\end{itemize}
