\section{Fernandez' algorithm in Ocaml}

This section documents the current implementation of Fernandez'
algorithm in Ocaml.

<<fernandez.ml>>=
#use "topfind";;
#require "inspect";;
open Inspect;;

@ 
\subsection{Data Types}
\begin{itemize}
\item Actions are denoted by integers from $0$ to $|Act|-1$
<<fernandez.ml>>=
type action = int;;
@ 
\item Each state in the LTS is denoted by a number from $0$ to $|Proc|
  - 1$
<<fernandez.ml>>=
type ltsindex = int;;
@ 
\item Each node stores its own adjacency list, sorted by the actions on the respective transitions.
<<fernandez.ml>>=
type node = {mutable in_adjacency: (action * (ltsindex list)) list};;
@ 
\item An LTS is represented as an array of nodes, each containing its
  adjacecnt list sorted by actions, and the total number of different
  actions in it.
<<fernandez.ml>>=
type lts = {nodes: node array; actions: action};;
@ 
\item A block is represented by a list of states from $Proc$.
<<fernandez.ml>>=
type block = ltsindex list;;
@ 
\item A partition is a set of blocks.
<<fernandez.ml>>=
type partition = block list;;
@ 
\item Splitters can be of two kinds, simple and compound.
<<fernandez.ml>>=
type splitter = Simple of block | Compound of (block * splitter * splitter);;
@ 
\end{itemize}

\subsection{Functions}
\begin{itemize}
\item $t$ is the tree, $x$ is the formerly simple block that was
  split into the new simple blocks $x1$ and $x2$.
<<fernandez.ml>>=
let rec twowayupdatetree t x x1 x2 =
  match t with
    Simple t0 -> if (t0 = x) then (Compound (x, Simple x1, Simple x2), true) else (t, false)
  | Compound (t0, t1, t2) -> (
      match (twowayupdatetree t1 x x1 x2) with
	(_, false) -> (
	  match (twowayupdatetree t2 x x1 x2) with
	    (_, false) -> (t, false)
	  | (tt2, true) -> (Compound (t0, t1, tt2), true)
	 )
      | (tt1, true) -> (Compound (t0, tt1, t2), true)
     )
;;

@ 
\item $w$ is the queue, $x$ is the formerly simple block that was
  split into the new simple blocks $x1$ and $x2$.
<<fernandez.ml>>=
let rec twowayupdatequeue w x x1 x2 =
  match w with
    [] -> [Compound (x, Simple x1, Simple x2)]
  | t::ts -> (match (twowayupdatetree t x x1 x2) with
      (_, false) -> t::(twowayupdatequeue ts x x1 x2)
    | (tt, true) -> tt::ts
     )
;;

@ 
\item $l$ is the lts, $x$ is the block being split, $b$ is the simple splitter, $a$ is the action.
<<fernandez.ml>>=
 let simplesplitblockonaction l x b a =
   List.partition (function xelem -> List.exists (function belem -> List.exists (function (aa, nl) -> a=aa && List.exists (function nlelem -> nlelem = xelem) nl) l.nodes.(belem).in_adjacency) b) x
 ;;

@ 
\item $l$ is the lts, $x$ is the block being split, $b$ is the
  compound splitter consisting of the blocks $b1$ and $b2$, $a$ is the
  action. This returns an ordered pair of ordered pairs, the four
  elements of which contain $x \cap T_{a}^{-1}[b1] \cap T_{a}^{-1}[b2]$, $x
  \cap T_{a}^{-1}[b1] - T_{a}^{-1}[b2]$, $x \cap T_{a}^{-1}[b2] -
  T_{a}^{-1}[b1]$, and
  $x - T_{a}^{-1}[b2] - T_{a}^{-1}[b1]$.
<<fernandez.ml>>=
let compoundsplitblockonaction l x b b1 b2 a = let
  f = function xelem -> List.exists (function belem -> List.exists (function (aa, nl) -> a=aa && List.exists (function nlelem -> nlelem = xelem) nl) l.nodes.(belem).in_adjacency)
  in match
  (List.partition (function xelem -> f xelem b1) x)
  with
  (y1, y2) -> (List.partition (function xelem -> f xelem b2) y1, List.partition (function xelem -> f xelem b2) y2)
;;

@ 
  \item $l$ is the LTS,  $w$ is the queue,  $xl$ is the list of blocks
  being split,  $b$ is the simple splitter,  $a$ is the action.
<<fernandez.ml>>=
let rec simplesplitblocksonaction l (w, xl) b a =
  match xl with
    [] -> (w, [])
  | x::xs -> (let (ww, xxs) = (simplesplitblocksonaction l (w, xs) b a) in (match (simplesplitblockonaction l x b a) with
      ([], x2) -> (ww, x2::xxs)
    | (x1, []) -> (ww, x1::xxs)
    | (x1, x2) -> (let www = (twowayupdatequeue ww x x1 x2) in (www, x1::x2::xxs))
									   ))
;;

@ 
  \item $l$ is the LTS, $w$ is the queue, $xl$ is the list of blocks
      being split, $b$ is the compound  splitter which consists of
	  blocks $b1$ and $b2$, $a$ is the action.
<<fernandez.ml>>=
let rec compoundsplitblocksonaction l (w, xl) b b1 b2 a =
  match xl with
    [] -> (w, [])
  | x::xs -> (let (ww, xxs) = (compoundsplitblocksonaction l (w, xs) b b1 b2 a) in (match (compoundsplitblockonaction l x b b1 b2 a) with
      (([], []), ([], x4)) -> (ww, x4::xxs)
    | (([], x1), ([], [])) -> (ww, x1::xxs)
    | (([], []), (x2, [])) -> (ww, x2::xxs)
    | ((x3, []), ([], [])) -> (ww, x3::xxs)
    | ((x3, x1), ([], [])) -> (let www = (twowayupdatequeue ww x x3 x1) in (www, x3::x1::xxs))
    | ((x3, []), (x2, [])) -> (let www = (twowayupdatequeue ww x x3 x2) in (www, x3::x2::xxs))
    | (([], x1), (x2, [])) -> (let www = (twowayupdatequeue ww x x1 x2) in (www, x1::x2::xxs))
    | ((x3, x1), (x2, [])) -> (let www = (twowayupdatequeue (twowayupdatequeue ww x x1 (x2@x3)) (x2@x3) x2 x3) in (www, x1::x2::x3::xxs))
     ))
;;

@ 
\item $l$ is the LTS, $w$ is the queue, $pi$ is the partition being
  split, $sp$ is the splitter (simple or compound), $a$ is the action.
<<fernandez.ml>>=
(*
  alias for sanity
 *)
let splitpartitiononaction l (w, pi) sp a = match sp with
  Simple b -> simplesplitblocksonaction l (w, pi) b a
| Compound (b, Simple b1, Simple b2) -> compoundsplitblocksonaction l (w, pi) b b1 b2 a
| Compound (b, Compound (b1, _, _), Simple b2) -> compoundsplitblocksonaction l (w, pi) b b1 b2 a
| Compound (b, Simple b1, Compound (b2, _, _)) -> compoundsplitblocksonaction l (w, pi) b b1 b2 a
| Compound (b, Compound (b1, _, _), Compound (b2, _, _)) -> compoundsplitblocksonaction l (w, pi) b b1 b2 a
;;

@ 
  \item $l$ is the LTS, $pi$ is the partition being split, $w$ is the
  queue, $b$ is the splitter, $a$ is the LAST action to split
  $pi$ on.
<<fernandez.ml>>=
(*
 *)
let rec splitpartitiononactions l (w, pi) b a =
  match a with
    0 -> splitpartitiononaction l (w, pi) b 0
  | a -> splitpartitiononaction l (splitpartitiononactions l (w, pi) b (a-1)) b a
;;

@ 
\item $l$ is the LTS, $w$ is the queue, $pi$ is the partition being
  split.
<<fernandez.ml>>=
let dequeue l (w, pi) = match w with
  [] -> ([], pi)
| (Simple b)::wtail -> splitpartitiononactions l (wtail, pi) (Simple
								b)
  (l.actions - 1)
| (Compound (b, b1, b2))::wtail -> splitpartitiononactions l
  (wtail@[b1; b2], pi) (Compound (b, b1, b2)) (l.actions - 1)
;;

@ 
\item $l$ is the LTS, $w$ is the queue, $pi$ is the partition being
  split.
<<fernandez.ml>>=
let rec emptyqueue l (w, pi) = match w with
  [] -> ([], pi)
| whead::wtail -> emptyqueue l (dequeue l (w, pi))
;;

@ 
\item This function, given $n$, returns a list with the elements $n-1,
  ..., 0$
<<fernandez.ml>>=
let rec getblock n = match n with
  0 -> []
| n -> (n-1)::(getblock (n-1))
;;
      
@ 
\item $l$ is the LTS.
<<fernandez.ml>>=
let fernandez l = let llist = getblock (Array.length l.nodes) in emptyqueue l ([Simple llist], [llist])
;;

@ 
\end{itemize}

<<fernandez.ml>>=
let lts1 = {nodes=[|{in_adjacency = [(2, [6])]}; 
	     {in_adjacency = [(0, [1])]}; 
	     {in_adjacency = [(0, [0]); (1, [7])]};
	     {in_adjacency = [(1, [2])]};
	     {in_adjacency = [(1, [2])]};
	     {in_adjacency = [(0, [4; 5]); (2, [6])]};
	     {in_adjacency = [(1, [3]); (2, [2])]};
	     {in_adjacency = [(0, [1])]}|]; actions=3}
;;

let x1 = [0; 1; 2; 3; 4; 5; 6; 7];;
let b1 = [0; 1; 2; 3; 4; 5; 6; 7];;
let pi1 = [[0; 1; 2; 3; 4; 5; 6; 7]];;
let a1 = 0;;
let w1 = [];;
let (w1, pi1) = simplesplitblocksonaction lts1 (w1, pi1) b1 a1;;
let a1 = 1;;
let (w1, pi1) = simplesplitblocksonaction lts1 (w1, pi1) b1 a1;;
let a1 = 2;;
let (w1, pi1) = simplesplitblocksonaction lts1 (w1, pi1) b1 a1;;
let b2 = [0; 1; 2; 3; 4; 5; 6; 7];;
let b3 = [0; 1; 4; 5];;
let b4 = [2; 3; 6; 7];;
let pi2 = [[0; 1; 4; 5; 2; 3; 6; 7]];;
let w2 = [Simple [0; 1; 2; 3; 4; 5; 6; 7]];;
let a2 = 2;;
let lts1 = {nodes=[|{in_adjacency = [(2, [6])]}; 
	     {in_adjacency = [(0, [1])]}; 
	     {in_adjacency = [(0, [0]); (1, [7])]};
	     {in_adjacency = [(1, [2])]};
	     {in_adjacency = [(1, [2])]};
	     {in_adjacency = [(0, [4; 5]); (2, [6])]};
	     {in_adjacency = [(1, [3]); (2, [2])]};
	     {in_adjacency = [(0, [1])]}|]; actions=3}
;;
let (w2, pi2) = fernandez lts1;;
let lts2 = {nodes=[|{in_adjacency = [(0, [5])]}; 
	     {in_adjacency = [(0, [0; 1])]}; 
	     {in_adjacency = [(1, [4])]};
	     {in_adjacency = [(0, [6]); (1, [2])]};
	     {in_adjacency = [(1, [3])]};
	     {in_adjacency = []};
	     {in_adjacency = [(1, [5])]}
	   |]; actions=2}
;;
let (w3, pi3) = fernandez lts2;;
